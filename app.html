<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StruML - Structured Markup Language</title>
    
    <!-- Core CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://unpkg.com/@yaireo/tagify@4.17.8/dist/tagify.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@yaireo/dragsort/dist/dragsort.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@yaireo/dragsort/dist/dragsort.css">
    <link href="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/tabulator-tables@5.5.0/dist/css/tabulator.min.css" rel="stylesheet">

    <!-- D3.js and Sankey libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

    <style>
        body {
            overflow-x: hidden;
            background-color: var(--bs-body-bg);
        }
        
        #app-container {
            display: flex;
            min-height: 100vh;
        }
        
        #sidebar {
            position: fixed;
            height: 100vh;
            width: 380px;
            top: 0;
            left: 0;
            z-index: 1030;
            overflow-y: auto;
            background-color: var(--bs-body-bg);
            border-right: 1px solid var(--bs-border-color);
            transition: transform 0.3s ease;
        }
        
        #sidebar.collapsed {
            transform: translateX(-380px);
        }
        
        #main-content {
            flex: 1;
            transition: margin-left 0.3s;
            padding: 20px;
            margin-left: 380px;
            padding-top: 65px;
            max-width: calc(90vw - 380px);
            margin-right: auto;
        }
        
        @media (min-width: 1600px) {
            #main-content {
                max-width: 1200px;
            }
        }
        
        #main-content.expanded {
            margin-left: 0;
            max-width: 90vw;
        }
        
        .main-header {
            top: 0;
            right: 0;
            z-index: 1020;
            transition: left 0.3s ease;
            background-color: var(--bs-body-bg);
            border-bottom: 1px solid var(--bs-border-color);
        }
        
        .main-header.expanded {
            left: 0;
        }
        
        .item-container {
            margin-bottom: 1rem;
            border: 1px solid var(--bs-border-color-translucent);
            border-radius: var(--bs-border-radius);
            background-color: var(--bs-card-bg);
            scroll-margin-top: 80px; /* Increased to ensure item is at top */
            position: relative;
        }
        
        .item-header {
            padding: 0.65rem 1rem;
            background-color: var(--bs-tertiary-bg);
            border-bottom: 1px solid var(--bs-border-color-translucent);
            position: relative;
        }
        
        .item-title-area {
            display: flex;
            align-items: center;
            flex: 1;
            position: relative;
        }
        
        .item-title {
            margin-bottom: 0;
            font-weight: 500;
        }
        
        .item-content {
            padding: 0.75rem;
        }
        
        .item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-left: 0.5rem;
        }
        
        .item-tag {
            font-size: 0.7rem;
            padding: 0.15rem 0.35rem;
            border-radius: var(--bs-border-radius-sm);
            background-color: var(--bs-secondary-bg);
            color: var(--bs-secondary-color);
        }
        
        .item-children {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        
        .item-actions {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s ease;
            background-color: var(--bs-tertiary-bg);
            padding: 4px;
            border-radius: var(--bs-border-radius-sm);
            z-index: 100;
            display: flex;
        }
        
        .item-header:hover .item-actions {
            opacity: 1;
        }
        
        .action-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            border: none;
            border-radius: var(--bs-border-radius-sm);
            color: var(--bs-secondary-color);
        }
        
        .action-btn:hover {
            background-color: var(--bs-tertiary-bg);
        }
        
        .action-btn.add-btn {
            color: var(--bs-primary);
        }
        
        .doc-nav {
            list-style: none;
            padding-left: 0;
        }

        .doc-nav-item {
            margin-bottom: 0;
            line-height: 1.1;
        }
        
        .doc-nav-toggle {
            cursor: pointer;
            display: inline-block;
            width: 16px;
            text-align: center;
        }
        
        .doc-nav-indent {
            display: inline-block;
            width: 4px;
            color: var(--bs-secondary-color);
        }
        
        .doc-nav-link {
            display: inline-block;
            color: var(--bs-body-color);
            text-decoration: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: all 0.2s;
            border-radius: var(--bs-border-radius-sm);
            max-width: 300px;
            font-size: 0.85rem;
        }

        .doc-nav-link:hover {
            background-color: var(--bs-tertiary-bg);
        }

        .doc-nav-link.active {
            background-color: var(--bs-primary);
            color: white;
        }
        
        .item-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            margin-right: 10px;
            font-size: 1.1rem;
        }
        
        .list-priority .item-icon { color: var(--bs-danger); }
        .list-weight .item-icon { color: var(--bs-success); }
        .list-sequence .item-icon { color: var(--bs-primary); }
        .list-steps .item-icon { color: var(--bs-info); }
        .list-temporality .item-icon { color: var(--bs-purple); }
        .list-range .item-icon { color: var(--bs-orange); }
        .list-category .item-icon { color: var(--bs-warning); }
        .list-matrix .item-icon { color: var(--bs-teal); }
        
        .item-children .item-container:nth-child(1) .item-icon { opacity: 1; }
        .item-children .item-container:nth-child(2) .item-icon { opacity: 0.7; }
        .item-children .item-container:nth-child(3) .item-icon { opacity: 0.5; }
        .item-children .item-container:nth-child(n+4) .item-icon { opacity: 0.3; }

        #tag-filter-accordion .accordion-button.filtering {
            background-color: rgba(var(--bs-primary-rgb), 0.2);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { background-color: rgba(var(--bs-tertiary-bg-rgb), 1); }
            50% { background-color: rgba(var(--bs-primary-rgb), 0.2); }
            100% { background-color: rgba(var(--bs-tertiary-bg-rgb), 1); }
        }

        .modal .CodeMirror {
            height: 200px;
        }
        
        .app-logo {
            font-size: 2rem; 
            font-weight: normal;
            font-family: 'Playfair Display', serif; 
            color: #4B0082;
        }

        .sortable-ghost {
            opacity: 0.4;
            background-color: var(--bs-tertiary-bg);
        }
        
        .sortable-chosen {
            background-color: var(--bs-secondary-bg);
        }
        
        .item-drag-handle {
            cursor: move;
        }
        
        .item-tag.special-tag {
            background-color: var(--bs-info-bg-subtle);
            color: var(--bs-info);
            border: 1px solid var(--bs-info-border-subtle);
        }

        .item-tag.relation-tag {
            background-color: var(--bs-primary-bg-subtle);
            color: var(--bs-primary);
            border: 1px solid var(--bs-primary-border-subtle);
        }

        /* Relation level styles */
        .item-tag.relation-extremely-high {
            background-color: rgb(0, 110, 0, 0.1);
            color: rgb(0, 110, 0);
            border-color: rgb(0, 110, 0, 0.2);
        }

        /* New dynamic relation color classes - Blues (1-5) */
        .relation-blue-1 {
            background-color: rgba(0, 0, 255, 0.1);
            color: rgba(0, 0, 255, 0.8);
            border-color: rgba(0, 0, 255, 0.2);
        }
        .relation-blue-2 {
            background-color: rgba(0, 0, 255, 0.2);
            color: rgba(0, 0, 255, 0.9);
            border-color: rgba(0, 0, 255, 0.3);
        }
        .relation-blue-3 {
            background-color: rgba(0, 0, 255, 0.15);
            color: rgba(0, 0, 180, 1);
            border-color: rgba(0, 0, 255, 0.3);
        }
        .relation-blue-4 {
            background-color: rgba(0, 0, 255, 0.2);
            color: rgba(0, 0, 150, 1);
            border-color: rgba(0, 0, 255, 0.4);
        }
        .relation-blue-5 {
            background-color: rgba(0, 0, 255, 0.25);
            color: rgba(0, 0, 120, 1);
            border-color: rgba(0, 0, 255, 0.5);
        }

        /* Green values (+1 to +10) */
        .relation-green-1 {
            background-color: rgba(0, 128, 0, 0.1);
            color: rgba(0, 128, 0, 0.8);
            border-color: rgba(0, 128, 0, 0.2);
        }
        .relation-green-2 {
            background-color: rgba(0, 128, 0, 0.15);
            color: rgba(0, 128, 0, 0.9);
            border-color: rgba(0, 128, 0, 0.3);
        }
        .relation-green-3 {
            background-color: rgba(0, 128, 0, 0.15);
            color: rgba(0, 110, 0, 1);
            border-color: rgba(0, 128, 0, 0.3);
        }
        .relation-green-4 {
            background-color: rgba(0, 128, 0, 0.2);
            color: rgba(0, 100, 0, 1);
            border-color: rgba(0, 128, 0, 0.4);
        }
        .relation-green-5 {
            background-color: rgba(0, 128, 0, 0.25);
            color: rgba(0, 80, 0, 1);
            border-color: rgba(0, 128, 0, 0.5);
        }

        /* Red values (-1 to -10) */
        .relation-red-1 {
            background-color: rgba(255, 0, 0, 0.1);
            color: rgba(200, 0, 0, 0.8);
            border-color: rgba(255, 0, 0, 0.2);
        }
        .relation-red-2 {
            background-color: rgba(255, 0, 0, 0.15);
            color: rgba(200, 0, 0, 0.9);
            border-color: rgba(255, 0, 0, 0.3);
        }
        .relation-red-3 {
            background-color: rgba(255, 0, 0, 0.15);
            color: rgba(180, 0, 0, 1);
            border-color: rgba(255, 0, 0, 0.3);
        }
        .relation-red-4 {
            background-color: rgba(255, 0, 0, 0.2);
            color: rgba(160, 0, 0, 1);
            border-color: rgba(255, 0, 0, 0.4);
        }
        .relation-red-5 {
            background-color: rgba(255, 0, 0, 0.25);
            color: rgba(140, 0, 0, 1);
            border-color: rgba(255, 0, 0, 0.5);
        }
        
        .item-tag.relation-very-high {
            background-color: rgb(23, 162, 23, 0.1);
            color: rgb(23, 162, 23);
            border-color: rgb(23, 162, 23, 0.2);
        }
        
        .item-tag.relation-high {
            background-color: rgb(44, 186, 0, 0.1);
            color: rgb(44, 186, 0);
            border-color: rgb(44, 186, 0, 0.2);
        }
        
        .item-tag.relation-slightly-high {
            background-color: rgb(100, 220, 0, 0.1);
            color: rgb(100, 220, 0);
            border-color: rgb(100, 220, 0, 0.2);
        }
        
        .item-tag.relation-neutral {
            background-color: rgb(128, 128, 128, 0.1);
            color: rgb(128, 128, 128);
            border-color: rgb(128, 128, 128, 0.2);
        }
        
        .item-tag.relation-slightly-low {
            background-color: rgb(255, 200, 0, 0.1);
            color: rgb(255, 200, 0);
            border-color: rgb(255, 200, 0, 0.2);
        }
        
        .item-tag.relation-low {
            background-color: rgb(255, 150, 0, 0.1);
            color: rgb(255, 150, 0);
            border-color: rgb(255, 150, 0, 0.2);
        }
        
        .item-tag.relation-very-low {
            background-color: rgb(255, 100, 0, 0.1);
            color: rgb(255, 100, 0);
            border-color: rgb(255, 100, 0, 0.2);
        }
        
        .item-tag.relation-extremely-low {
            background-color: rgb(255, 0, 0, 0.1);
            color: rgb(255, 0, 0);
            border-color: rgb(255, 0, 0, 0.2);
        }
        
        .tabulator {
            margin-top: 1rem;
            margin-bottom: 1rem;
            width: 100%;
        }

        .table-toolbar {
            margin: 1rem 0;
            display: flex;
            gap: 0.5rem;
        }
        
        .relation-section {
            border-top: 1px solid var(--bs-border-color);
            margin-top: 1rem;
            padding-top: 1rem;
        }
        
        .relation-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .relation-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }
        
        .relation-tag {
            display: inline-flex;
            align-items: center;
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
            border-radius: var(--bs-border-radius-sm);
            background-color: var(--bs-primary-bg-subtle);
            color: var(--bs-primary);
            border: 1px solid var(--bs-primary-border-subtle);
        }
        
        .relation-tag i {
            margin-right: 0.25rem;
            font-size: 0.7rem;
        }
        
        .matrix-editor {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid var(--bs-border-color);
            border-radius: var(--bs-border-radius);
            background-color: var(--bs-body-bg);
        }

        .matrix-visualization {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: var(--bs-border-radius);
        }

        .matrix-visualization-title {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--bs-primary);
            border-bottom: 1px solid var(--bs-border-color);
            padding-bottom: 0.5rem;
        }

        .matrix-action-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 1rem;
        }

        .d3-tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            z-index: 1100;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .visualization-container {
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }

        /* Heatmap specific styles */
        .heatmap-cell rect {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .heatmap-cell:hover rect {
            opacity: 0.8;
        }
        
        /* Sankey diagram specific styles */
        .sankey-node rect {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .sankey-node:hover rect {
            opacity: 0.8;
        }
        
        .sankey-link {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .sankey-link:hover {
            opacity: 0.8;
        }
        
        /* Ensure heatmap has horizontal scrolling */
        .heatmap-container {
            overflow-x: auto;
            max-width: 100%;
        }
        
        /* Matrix cell hover tooltip */
        .matrix-cell-tooltip {
            position: absolute;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            z-index: 1100;
            max-width: 300px;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <nav id="main-header" class="main-header navbar navbar-expand-lg navbar-light py-2 px-3">
        <div class="container-fluid">
            <div class="d-flex align-items-center">
                <button id="expand-sidebar-btn" class="btn btn-sm me-2 d-none" title="Show sidebar">
                    <i class="bi bi-layout-sidebar-inset"></i>
                </button>
                <span id="document-title" class="h5 mb-0" tabindex="-1">Untitled Document</span>
            </div>
            <div class="d-flex gap-2 align-items-center">
                <button id="matrix-view-btn" class="btn btn-outline-primary btn-sm">
                    <i class="bi bi-grid-3x3-gap me-1"></i> Matrix View
                </button>
                <button id="chat-open-btn" class="btn btn-outline-primary btn-sm">
                    <i class="bi bi-chat-dots me-1"></i> AI Assistant
                </button>
                <div class="dropdown">
                    <button class="btn btn-outline-primary btn-sm dropdown-toggle" type="button" id="export-dropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-download me-1"></i> Export/Import
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="export-dropdown">
                        <li><a class="dropdown-item" id="export-json-btn" href="#"><i class="bi bi-filetype-json me-2"></i>Export as JSON</a></li>
                        <li><a class="dropdown-item" id="export-md-btn" href="#"><i class="bi bi-filetype-md me-2"></i>Export as Markdown</a></li>
                        <li><a class="dropdown-item" id="export-html-btn" href="#"><i class="bi bi-filetype-html me-2"></i>Export as HTML</a></li>
                        <li><a class="dropdown-item" id="export-docx-btn" href="#"><i class="bi bi-file-earmark-word me-2"></i>Export as DOCX</a></li>
                        <li><a class="dropdown-item" id="export-csv-btn" href="#"><i class="bi bi-filetype-csv me-2"></i>Export as CSV</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" id="import-json-btn" href="#"><i class="bi bi-upload me-2"></i>Import JSON</a></li>
                    </ul>
                </div>
                <button id="import-btn" class="btn btn-outline-secondary btn-sm">
                    <i class="bi bi-upload me-1"></i> Import
                </button>
                <button id="clear-btn" class="btn btn-outline-danger btn-sm">
                    <i class="bi bi-trash me-1"></i> Clear
                </button>
            </div>
        </div>
    </nav>

    <div id="app-container">
        <div id="sidebar" class="p-3">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h5 class="app-logo" id="sidebarLabel">StruML</h5>
                <button type="button" class="btn-close" id="collapse-sidebar-btn" aria-label="Close"></button>
            </div>
            <div class="sidebar-content p-0">
                <div class="accordion mb-3" id="tag-filter-accordion">
                    <div class="accordion-item">
                        <h2 class="accordion-header">
                            <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#tag-filter-collapse" id="tag-filter-btn">
                                <i class="bi bi-tags me-2"></i> Filter by Tags
                            </button>
                        </h2>
                        <div id="tag-filter-collapse" class="accordion-collapse collapse show" data-bs-parent="#tag-filter-accordion">
                            <div class="accordion-body">
                                <div class="mb-2">
                                    <div class="d-flex flex-column mb-2">
                                        <div class="mb-2">
                                            <select id="tag-filter-mode" class="form-select form-select-sm">
                                                <option value="OR">OR - Match any tag</option>
                                                <option value="AND">AND - Match all tags</option>
                                            </select>
                                        </div>
                                        <div class="form-check form-switch">
                                            <input class="form-check-input" type="checkbox" role="switch" id="show-subitems-checkbox" checked>
                                            <label class="form-check-label" for="show-subitems-checkbox">Show subitems</label>
                                        </div>
                                    </div>
                                </div>
                                <div id="tag-filters" class="d-flex flex-wrap gap-1 mb-2"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mb-3">
                    <h6 class="fs-6 mb-2">Document Navigation</h6>
                    <div id="document-navigation" class="doc-nav"></div>
                </div>
                
                <div class="text-center mt-4">
                    <button 
                        id="add-top-item-btn" 
                        class="btn btn-outline-primary"
                    >
                        <i class="bi bi-plus-circle me-2"></i> Add Item
                    </button>
                </div>
            </div>
        </div>
        
        <div id="main-content">
            <div id="welcome-screen">
                <div class="text-center py-5">
                    <h1 class="display-5 mb-3">Welcome to StruML</h1>
                    <p class="lead mb-5">Create, organize, and structure your domain knowledge</p>
                    
                    <div class="dropzone border border-2 border-dashed p-5 rounded mb-4 bg-body-tertiary" id="file-dropzone">
                        <i class="bi bi-cloud-upload display-4 mb-2"></i>
                        <p>Drag and drop your JSON file here or click to select</p>
                        <button class="btn btn-outline-primary mt-2">Select File</button>
                    </div>
                    <input type="file" id="file-input" accept=".json" class="d-none">
                    
                    <button id="create-new-btn" class="btn btn-primary">Create New Document</button>
                </div>
            </div>
            
            <div id="document-content" class="d-none"></div>
        </div>
    </div>
    
    <div class="offcanvas offcanvas-end" tabindex="-1" id="chatbot-panel" aria-labelledby="chatbotPanelLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="chatbotPanelLabel">AI Assistant</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="close-chatbot-btn" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div id="chat-context-info" class="mb-3">
                <p class="mb-1 fw-bold">Current section: <span id="current-item-title">None selected</span></p>
            </div>
            <div id="chat-messages" class="border rounded p-3 mb-3 overflow-auto" style="height: 300px;">
            </div>
            <div id="chat-input-container">
                <div class="input-group mb-3">
                    <input type="text" id="chat-input" class="form-control" placeholder="Type your question...">
                    <button id="chat-send-btn" class="btn btn-primary">
                        <i class="bi bi-send"></i>
                    </button>
                </div>
            </div>
            <div id="chat-loading" class="d-none">
                <div class="d-flex justify-content-center align-items-center">
                    <div class="spinner-border text-primary spinner-border-sm me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span>This might take a moment...</span>
                </div>
            </div>
            <div id="suggested-items" class="mt-4">
                <h5>Add sub-items to <span id="suggested-items-current"></span></h5>
                <div id="suggested-items-list">
                    <div class="alert alert-info">No suggested items available yet.</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="offcanvas offcanvas-end" tabindex="-1" id="info-panel" aria-labelledby="infoPanelLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="info-panel-title">Information</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" id="close-info-btn" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div id="related-items" class="related-items d-none">
                <h5>Related Items</h5>
                <div id="related-items-list"></div>
            </div>
            <div id="info-panel-content"></div>
        </div>
    </div>
    
    <div class="modal fade" id="item-editor-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="item-editor-title">Edit Item</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="item-editor-form">
                        <div class="mb-3">
                            <label for="item-title" class="form-label">Title</label>
                            <input type="text" class="form-control" id="item-title" required>
                        </div>
                        <div class="mb-3">
                            <label for="item-tags" class="form-label">Tags</label>
                            <input type="text" class="form-control" id="item-tags">
                            <div class="form-text mt-1">
                                Use comma-separated tags. Special tag format: <code>type::value</code> is used for items classification.
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="form-text mt-2">
                                To specify a list type, add a tag with format <code>type::priority</code>, <code>type::weight</code>, <code>type::sequence</code>, etc.
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="item-content" class="form-label">Content</label>
                            <textarea class="form-control" id="item-content" rows="5"></textarea>
                        </div>
                        <div class="mb-3" id="relations-editor-container">
                            <label class="form-label">Add Relation</label>
                            <div id="relations-editor" class="border rounded p-3">
                                <div id="relations-list" class="mb-3"></div>
                                <div class="row">
                                    <div class="col-md-4">
                                        <input type="text" id="relation-type" class="form-control mb-2" placeholder="Relation type (e.g. depends, high)">
                                    </div>
                                    <div class="col-md-6">
                                        <input type="text" id="relation-target" class="form-control mb-2" placeholder="Target item title">
                                    </div>
                                    <div class="col-md-2">
                                        <button type="button" id="add-relation-btn" class="btn btn-primary w-100">
                                            <i class="bi bi-plus-lg"></i> Add
                                        </button>
                                    </div>
                                </div>
                                <div class="form-text">
                                    <small>Common relation types: extremely-high, very-high, high, slightly-high, neutral, slightly-low, low, very-low, extremely-low, depends, related</small>
                                </div>
                            </div>
                        </div>
                        <input type="hidden" id="item-id">
                        <input type="hidden" id="parent-id">
                        <input type="hidden" id="original-title">
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger me-auto" id="delete-item-btn">Delete</button>
                    <button type="button" class="btn btn-primary" id="save-item-btn">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="update-relations-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Update Relations</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>The item title has changed. Would you like to update all references to this item in relation tags?</p>
                    <p><strong>Old title:</strong> <span id="old-title-ref"></span></p>
                    <p><strong>New title:</strong> <span id="new-title-ref"></span></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="skip-update-btn">No, Keep Old References</button>
                    <button type="button" class="btn btn-primary" id="confirm-update-btn">Yes, Update References</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="matrix-editor-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Matrix Editor</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <div class="row">
                            <div class="col-md-4">
                                <label class="form-label">Source Item (Rows)</label>
                                <select id="source-item-select" class="form-select">
                                    <option value="">Select item for rows...</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <label class="form-label">Target Item (Columns)</label>
                                <select id="target-item-select" class="form-select">
                                    <option value="">Select item for columns...</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label">Cell Values (semicolon-separated)</label>
                                <input type="text" id="matrix-cell-values" class="form-control" 
                                       placeholder="e.g. extremely-high;very-high;high;slightly-high;neutral">
                            </div>
                            <div class="col-md-1">
                                <label class="form-label">&nbsp;</label>
                                <button id="load-matrix-btn" class="btn btn-primary w-100">Load</button>
                            </div>
                        </div>
                    </div>
                    <div class="matrix-editor" id="matrix-container">
                        <div class="alert alert-info">Select source and target items to build the matrix</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="save-matrix-btn">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="delete-confirm-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm Deletion</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete this item? This will also delete all child items.</p>
                    <p class="text-danger"><strong>This action cannot be undone.</strong></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirm-delete-btn">Delete</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal fade" id="clear-confirm-modal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm Clear</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to clear the current document? This will remove all items.</p>
                    <p class="text-danger"><strong>This action cannot be undone.</strong></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirm-clear-btn">Clear Document</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="d3-tooltip" id="d3-tooltip"></div>
    <div class="matrix-cell-tooltip" id="matrix-cell-tooltip" style="display: none;"></div>
    
    <div class="toast-container position-fixed top-0 end-0 p-3" id="toast-container">
    </div>
    
    <!-- Core libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone@7.23.2/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://unpkg.com/@yaireo/tagify@4.17.8/dist/tagify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="https://unpkg.com/tabulator-tables@5.5.0/dist/js/tabulator.min.js"></script>
    
    <!-- Export libraries -->
    <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/json2md@2.0.0/dist/json2md.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx@8.0.4/build/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    
    <!-- Add UUID library implementation -->
    <script>
        // Add UUID library implementation
        !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).uuidv4=e()}(this,(function(){"use strict";var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto),e=new Uint8Array(16);function o(){if(!t)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(e)}var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function r(t){return"string"==typeof t&&n.test(t)}for(var i=[],f=0;f<256;++f)i.push((f+256).toString(16).substr(1));return function(t,e,n){var f=(t=t||{}).random||(t.rng||o)();if(f[6]=15&f[6]|64,f[8]=63&f[8]|128,e){n=n||0;for(var u=0;u<16;++u)e[n+u]=f[u];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=(i[t[e+0]]+i[t[e+1]]+i[t[e+2]]+i[t[e+3]]+"-"+i[t[e+4]]+i[t[e+5]]+"-"+i[t[e+6]]+i[t[e+7]]+"-"+i[t[e+8]]+i[t[e+9]]+"-"+i[t[e+10]]+i[t[e+11]]+i[t[e+12]]+i[t[e+13]]+i[t[e+14]]+i[t[e+15]]).toLowerCase();if(!r(o))throw TypeError("Stringified UUID is invalid");return o}(f)}}));
    </script>
    <script type="text/babel" data-presets="react">
    // Constants
    const WEBHOOK_URL = "http://n8n.lucascervera.com/webhook/strubasechatbot";
    const LOCAL_STORAGE_KEY = 'strudol-data';
    const LIST_TYPES = {
        priority: { icon: 'bi-bullseye', color: 'danger' },
        weight: { icon: 'bi-shield', color: 'success' },
        sequence: { icon: 'bi-collection', color: 'primary' },
        steps: { icon: 'bi-diagram-3', color: 'info' },
        temporality: { icon: 'bi-calendar-event', color: 'purple' },
        range: { icon: 'bi-graph-up-arrow', color: 'orange' },
        category: { icon: 'bi-folder', color: 'warning' },
        matrix: { icon: 'bi-table', color: 'teal' }
    };
    
    // Relation types and their icons - Extended with full spectrum
    const RELATION_TYPES = {
        'extremely-high': { icon: 'bi-arrow-up-circle-fill', label: 'Extremely High', level: 'extremely-high', value: 9 },
        'very-high': { icon: 'bi-arrow-up-circle-fill', label: 'Very High', level: 'very-high', value: 8 },
        'high': { icon: 'bi-arrow-up-circle-fill', label: 'High', level: 'high', value: 7 },
        'slightly-high': { icon: 'bi-arrow-up-circle-fill', label: 'Slightly High', level: 'slightly-high', value: 6 },
        'neutral': { icon: 'bi-dash-circle-fill', label: 'Neutral', level: 'neutral', value: 5 },
        'slightly-low': { icon: 'bi-arrow-down-circle-fill', label: 'Slightly Low', level: 'slightly-low', value: 4 },
        'low': { icon: 'bi-arrow-down-circle-fill', label: 'Low', level: 'low', value: 3 },
        'very-low': { icon: 'bi-arrow-down-circle-fill', label: 'Very Low', level: 'very-low', value: 2 },
        'extremely-low': { icon: 'bi-arrow-down-circle-fill', label: 'Extremely Low', level: 'extremely-low', value: 1 },
        'related': { icon: 'bi-link', label: 'Related', level: '', value: 1 },
        'depends': { icon: 'bi-box-arrow-in-down-right', label: 'Depends on', level: '', value: 1 }
    };
    
    // Bootstrap components initialization
    const root = ReactDOM.createRoot(document.getElementById('document-content'));
    const chatbotPanel = new bootstrap.Offcanvas(document.getElementById('chatbot-panel'));
    const infoPanel = new bootstrap.Offcanvas(document.getElementById('info-panel'));
    
    /**
     * Utility functions for the application
     */
    const Utils = {
        // Store current scroll position before modal opens
        scrollPosition: 0,
        
        // Store current cell tooltip
        matrixCellTooltip: null,
        
        // Save current scroll position
        saveScrollPosition() {
            this.scrollPosition = window.scrollY;
        },
        
        // Restore saved scroll position
        restoreScrollPosition() {
            setTimeout(() => {
                window.scrollTo(0, this.scrollPosition);
            }, 10);
        },
        
        // ID generation - always use UUID or fallback to random string
        generateItemId() {
            // Check if uuidv4 is available
            if (typeof uuidv4 !== 'undefined') {
                return uuidv4();
            } else {
                // Fallback implementation for UUID
                return 'id-' + Math.random().toString(36).substring(2, 15) + 
                      Math.random().toString(36).substring(2, 15);
            }
        },
        
        // Extract type from tags
        getTypeFromTags(tags) {
            if (!tags) return '';
            const tagsList = tags.split(',').map(tag => tag.trim());
            const typeTag = tagsList.find(tag => tag.startsWith('type::'));
            return typeTag ? typeTag.split('::')[1] : '';
        },
        
        // Get icon for list type
        getListTypeIcon(type) {
            return LIST_TYPES[type]?.icon || 'bi-circle';
        },
        
        // Show alert toast
        showAlert(message, type = 'success', duration = 3000) {
            const toastId = `toast-${Date.now()}`;
            const toastHtml = `
                <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="toast-header">
                        <span class="bg-${type} rounded me-2" style="width:16px; height:16px;"></span>
                        <strong class="me-auto">StruML</strong>
                        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                    <div class="toast-body">
                        ${message}
                    </div>
                </div>
            `;
            
            const toastContainer = document.getElementById('toast-container');
            toastContainer.insertAdjacentHTML('beforeend', toastHtml);
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, { 
                autohide: true, 
                delay: duration 
            });
            
            toast.show();
            
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });
        },
        
        customValueMapping: {
        'max': 9,
        'very high': 8,
        'high': 7,
        'slightly high': 6,
        'neutral': 5,
        'slightly low': 4,
        'low': 3,
        'very low': 2,
        'min': 1
    },
    
    // Extract numeric value from relation names with number in parentheses
    // Example: "high (8)" or "good (+5)" or "bad (-3)"
    extractNumericValueFromRelation(relation) {
        if (!relation) return null;
        
        // Look for pattern: any text followed by a number in parentheses
        const match = relation.match(/\(([+-]?\d+)\)/);
        if (!match) return null;
        
        // Return the extracted number and whether it's positive
        const numString = match[1];
        const value = parseInt(numString, 10);
        const isPositive = numString.includes('+');
        
        return {
            value: Math.abs(value), // Absolute value (1-10)
            isPositive, // Explicitly marked as positive with +
            isNegative: value < 0, // Negative value
            original: relation // Keep original relation name
        };
    },
    
    // Get color for relation based on numeric value
    getColorForRelation(relation) {
        const extracted = this.extractNumericValueFromRelation(relation);
        if (!extracted) return null;
        
        const { value, isPositive, isNegative } = extracted;
        
        // Ensure value is between 1 and 10
        const normalizedValue = Math.min(Math.max(value, 1), 10);
        
        // Intensity ranges from 0.2 (lightest) to 0.9 (darkest)
        const intensity = 0.2 + (normalizedValue / 10) * 0.7;
        
        // Blue for neutral values (1-10)
        if (!isPositive && !isNegative) {
            return `rgba(0, 0, 255, ${intensity})`;
        }
        // Green for positive values (+1 to +10)
        else if (isPositive) {
            return `rgba(0, 128, 0, ${intensity})`;
        }
        // Red for negative values (-1 to -10)
        else if (isNegative) {
            return `rgba(255, 0, 0, ${intensity})`;
        }
        
        return null;
    },
    
    // Get CSS class for relation based on numeric value
    getRelationColorClass(relation) {
        const extracted = this.extractNumericValueFromRelation(relation);
        if (!extracted) return '';
        
        const { value, isPositive, isNegative } = extracted;
        
        // Ensure value is between 1 and 10
        const normalizedValue = Math.min(Math.max(value, 1), 10);
        
        // Scale value to 1-5 range for class names
        const intensityLevel = Math.ceil(normalizedValue / 2);
        
        // Blue for neutral values (1-10)
        if (!isPositive && !isNegative) {
            return `relation-blue-${intensityLevel}`;
        }
        // Green for positive values (+1 to +10)
        else if (isPositive) {
            return `relation-green-${intensityLevel}`;
        }
        // Red for negative values (-1 to -10)
        else if (isNegative) {
            return `relation-red-${intensityLevel}`;
        }
        
        return '';
    },
    
    
    // Función para convertir cualquier valor de relación a valor numérico
    getNumericValueForRelation(relation) {
        if (!relation) return 0;
        
        // Si es uno de nuestros valores estándar, usar el valor predefinido
        const knownRelation = RELATION_TYPES[relation.toLowerCase()];
        if (knownRelation) {
            return knownRelation.value;
        }
        
        // Buscar en el mapeo de valores personalizados
        const normalizedRelation = relation.toLowerCase();
        if (this.customValueMapping[normalizedRelation] !== undefined) {
            return this.customValueMapping[normalizedRelation];
        }
        
        // Para otros valores, intenta convertir a número o usa 1 como fallback
        const numericValue = parseInt(relation);
        return !isNaN(numericValue) ? Math.min(Math.max(numericValue, 1), 9) : 1;
    },
        
        // Render markdown content safely
        renderMarkdown(markdown) {
            if (!markdown) return '';
            
            const rawHtml = marked.parse(markdown);
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(rawHtml, 'text/html');
            doc.querySelectorAll('a').forEach(link => {
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
            });
            
            return DOMPurify.sanitize(doc.body.innerHTML, {
                USE_PROFILES: { html: true },
                ADD_ATTR: ['target', 'rel']
            });
        },
        
        // Find item by ID
        findItemById(items, id) {
            if (!items || !Array.isArray(items) || !id) return null;
            
            for (const item of items) {
                if (item.id === id) return item;
                
                if (item.items && item.items.length > 0) {
                    const found = this.findItemById(item.items, id);
                    if (found) return found;
                }
            }
            return null;
        },
    
        // Find item by title
        findItemByTitle(items, title) {
            if (!items || !Array.isArray(items) || !title) return null;
            
            for (const item of items) {
                if (item.title === title) return item;
                
                if (item.items && item.items.length > 0) {
                    const found = this.findItemByTitle(item.items, title);
                    if (found) return found;
                }
            }
            return null;
        },
        
        // Find parent of item by ID
        findParentOfItem(items, id, parent = null) {
            if (!items || !Array.isArray(items) || !id) return null;
            
            for (const item of items) {
                if (item.id === id) return parent;
                
                if (item.items && item.items.length > 0) {
                    const found = this.findParentOfItem(item.items, id, item);
                    if (found) return found;
                }
            }
            return null;
        },
        
        // Remove item by ID
        removeItemById(items, id) {
            if (!items || !Array.isArray(items) || !id) return false;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].id === id) {
                    items.splice(i, 1);
                    return true;
                }
                
                if (items[i].items && items[i].items.length > 0) {
                    if (this.removeItemById(items[i].items, id)) {
                        return true;
                    }
                }
            }
            return false;
        },
        
        // Add new item
        addItem(items, newItem, parentId = null) {
            if (!newItem) return false;
            
            if (!parentId) {
                items.push(newItem);
                return true;
            }
            
            const parent = this.findItemById(items, parentId);
            if (parent) {
                if (!parent.items) parent.items = [];
                
                if (!newItem.id) {
                    newItem.id = this.generateItemId();
                }
                
                parent.items.push(newItem);
                return true;
            }
            
            return false;
        },
        
        // Check if item has any of the specified tags
        itemHasAnyTag(item, tags) {
            if (!item.tags) return false;
            
            const itemTags = item.tags.split(',').map(tag => tag.trim())
                .filter(tag => !tag.startsWith('type::') && !tag.includes('>>'));
            return tags.some(tag => itemTags.includes(tag));
        },
        
        // Check if item has ALL of the specified tags (for AND mode)
        itemHasAllTags(item, tags) {
            if (!item.tags) return false;
            
            const itemTags = item.tags.split(',').map(tag => tag.trim())
                .filter(tag => !tag.startsWith('type::') && !tag.includes('>>'));
                
            return tags.every(tag => itemTags.includes(tag));
        },
    
        // Check if item or any child has any of the specified tags
        itemHasAnyTagRecursive(item, tags) {
            if (this.itemHasAnyTag(item, tags)) return true;
            
            if (item.items && item.items.length > 0) {
                return item.items.some(child => this.itemHasAnyTagRecursive(child, tags));
            }
            
            return false;
        },
        
        // Extract all tags from items, excluding special tags
        extractAllTags(items) {
            if (!items || !Array.isArray(items)) return [];
            
            const tagSet = new Set();
            
            const processTags = (item) => {
                if (item.tags) {
                    item.tags.split(',').forEach(tag => {
                        const trimmedTag = tag.trim();
                        // Skip special tags (with ::) and relation tags (with >>)
                        if (trimmedTag && !trimmedTag.includes('::') && !trimmedTag.includes('>>')) {
                            tagSet.add(trimmedTag);
                        }
                    });
                }
                
                if (item.items && item.items.length > 0) {
                    item.items.forEach(processTags);
                }
            };
            
            items.forEach(processTags);
            return Array.from(tagSet).sort();
        },
        
        // Filter items by tags with AND/OR logic and subitem control
        filterItemsByTags(items, tags, filterMode = 'OR', showSubItems = true) {
            if (tags.includes('all')) return items;
            
            // First, create a map of matching items and their ancestors
            const matchingItems = new Set();
            
            // Identify all matching items based on filter mode
            const findMatches = (item, path = []) => {
                const newPath = [...path, item.id];
                
                // For AND mode, the item must have ALL tags
                // For OR mode, the item must have ANY of the tags
                const isMatch = filterMode === 'AND' 
                    ? this.itemHasAllTags(item, tags)
                    : this.itemHasAnyTag(item, tags);
                    
                if (isMatch) {
                    // Add this item and all its ancestors to the set
                    newPath.forEach(id => matchingItems.add(id));
                    return true;
                }
                
                if (item.items && item.items.length > 0) {
                    const hasMatchingChild = item.items.some(child => 
                        findMatches(child, newPath)
                    );
                    if (hasMatchingChild) {
                        // Add this item and all its ancestors to the set
                        newPath.forEach(id => matchingItems.add(id));
                        return true;
                    }
                }
                return false;
            };
            
            items.forEach(item => findMatches(item));
            
            // Now clone the structure, keeping only matched items and their ancestors
            const cloneStructure = (itemsArray) => {
                return itemsArray
                    .filter(item => matchingItems.has(item.id))
                    .map(item => ({
                        ...item,
                        // If showSubItems is false, only include items that match the filter directly
                        items: (item.items && item.items.length > 0 && showSubItems) 
                            ? cloneStructure(item.items) 
                            : []
                    }));
            };
            
            return cloneStructure(items);
        },
        
        // Build HTML for document navigation - updated to collapse deep levels
        buildDocumentNavigationHtml(items, activeItemId = null, navExpandedItems = {}, depth = 0) {
            if (!items || items.length === 0) return '';
            
            let html = '<ul class="doc-nav">';
            
            items.forEach(item => {
                const isActive = item.id === activeItemId;
                const hasChildren = item.items && item.items.length > 0;
                const isExpanded = navExpandedItems[item.id];
                
                // Only expand top-level by default (depth === 0)
                const shouldBeExpanded = depth === 0 ? true : isExpanded;
                
                const listType = this.getTypeFromTags(item.tags) || '';
                const listIcon = this.getListTypeIcon(listType);
                
                html += `
                    <li class="doc-nav-item">
                        <div>
                            ${Array(depth).fill().map(() => 
                                `<span class="doc-nav-indent"><i class="bi bi-dash"></i></span>`
                            ).join('')}
                            
                            ${hasChildren ? 
                                `<span class="doc-nav-toggle" data-id="${item.id}">
                                    <i class="bi ${shouldBeExpanded ? 'bi-chevron-down' : 'bi-chevron-right'}"></i>
                                </span>` : 
                                `<span class="doc-nav-indent"></span>`
                            }
                            
                            <i class="bi ${listIcon} me-1" style="font-size: 0.8rem;"></i>
                            
                            <a class="doc-nav-link ${isActive ? 'active' : ''}" 
                               href="#${item.id}" 
                               data-id="${item.id}"
                               title="${item.title}">
                                ${item.title.substring(0, 35)}${item.title.length > 35 ? '...' : ''}
                            </a>
                        </div>
                        ${hasChildren ? 
                            `<div class="collapse ${shouldBeExpanded ? 'show' : ''}" id="nav-collapse-${item.id}">
                                ${this.buildDocumentNavigationHtml(item.items, activeItemId, navExpandedItems, depth + 1)}
                            </div>` : 
                            ''}
                    </li>
                `;
            });
            
            html += '</ul>';
            return html;
        },
        
        // Attach event handlers to navigation elements
        attachNavigationHandlers() {
            const navContainer = document.getElementById('document-navigation');
            if (!navContainer) return;
            
            // Toggle handlers
            navContainer.querySelectorAll('.doc-nav-toggle').forEach(toggle => {
                toggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    const itemId = e.currentTarget.dataset.id;
                    if (!itemId) return;
                    
                    const collapseElement = document.getElementById(`nav-collapse-${itemId}`);
                    if (!collapseElement) return;
                    
                    const icon = e.currentTarget.querySelector('i');
                    if (!icon) return;
                    
                    try {
                        const bsCollapse = bootstrap.Collapse.getOrCreateInstance(collapseElement);
                        
                        if (icon.classList.contains('bi-chevron-down')) {
                            bsCollapse.hide();
                            icon.classList.replace('bi-chevron-down', 'bi-chevron-right');
                            window.app?.toggleNavExpansion(itemId, false);
                        } else {
                            bsCollapse.show();
                            icon.classList.replace('bi-chevron-right', 'bi-chevron-down');
                            window.app?.toggleNavExpansion(itemId, true);
                        }
                    } catch (err) {
                        console.error('Navigation toggle error:', err);
                    }
                });
            });
            
            // Link click handlers
            navContainer.querySelectorAll('.doc-nav-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const itemId = e.currentTarget.dataset.id;
                    if (!itemId) return;
                    
                    window.app?.setCurrentItemId(itemId);
                    window.app?.scrollToItem(itemId);
                    
                    // Update active class
                    setTimeout(() => {
                        navContainer.querySelectorAll('.doc-nav-link').forEach(navLink => {
                            navLink.classList.remove('active');
                        });
                        e.currentTarget.classList.add('active');
                    }, 10);
                });
            });
        },
        
        // Show confirmation dialog for drag operations
        showDragConfirmation(source, target, onConfirm, onCancel) {
            const title = `Confirm Move`;
            const message = `Are you sure you want to move the item <strong>${source.title}</strong> ${target ? `to be a child of <strong>${target.title}</strong>` : 'to the top level'}?`;
            
            const modalHtml = `
                <div class="modal fade" id="drag-confirm-modal" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${title}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <p>${message}</p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" id="drag-cancel-btn" data-bs-dismiss="modal">Cancel</button>
                                <button type="button" class="btn btn-primary" id="drag-confirm-btn">Confirm</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            const modalElement = document.getElementById('drag-confirm-modal');
            
            const modal = new bootstrap.Modal(modalElement);
            
            document.getElementById('drag-cancel-btn').addEventListener('click', () => {
                if (onCancel) onCancel();
                modalElement.addEventListener('hidden.bs.modal', () => {
                    modalElement.remove();
                });
            });
            
            document.getElementById('drag-confirm-btn').addEventListener('click', () => {
                if (onConfirm) onConfirm();
                modal.hide();
                modalElement.addEventListener('hidden.bs.modal', () => {
                    modalElement.remove();
                });
            });
            
            modal.show();
        },
        
        // Get local path for markdown info files
        getLocalMarkdownPath(itemTitle) {
            const sanitizedTitle = itemTitle
                .replace(/[^a-zA-Z0-9]+/g, "_")
                .replace(/^_|_$/g, "");
            return `info/docs/pages/sections/${sanitizedTitle}.md`;
        },
        
        // Check if a tag is a relation tag
        isRelationTag(tag) {
            return tag.includes(">>") && tag.split(">>").length === 2;
        },
    
        // Get all relations from tags
        getRelationsFromTags(tags) {
            if (!tags) return [];
            
            return tags.split(',')
                .map(tag => tag.trim())
                .filter(tag => this.isRelationTag(tag))
                .map(relationTag => {
                    const [relation, target] = relationTag.split(">>");
                    return { 
                        relation, 
                        target: target.trim() 
                    };
                });
        },
    
        // Add a relation to item tags
        addRelationToTags(tags, relation, target) {
            if (!tags && !relation && !target) return '';
            
            // Handle case where tags might be a JSON string (from tagify)
            let normalizedTags = tags;
            if (tags && typeof tags === 'string' && tags.trim().startsWith('[{')) {
                try {
                    // Try to parse JSON formatted tags
                    const parsedTags = JSON.parse(tags);
                    if (Array.isArray(parsedTags)) {
                        // Extract 'value' property from each tag object
                        normalizedTags = parsedTags.map(tag => tag.value || '').filter(t => t).join(', ');
                    }
                } catch (err) {
                    // If parsing fails, use tags as-is
                    console.warn("Failed to parse tags JSON:", err);
                }
            }
            
            let tagList = normalizedTags ? normalizedTags.split(',').map(t => t.trim()).filter(t => t) : [];
            
            // Remove any existing relation to the same target
            tagList = tagList.filter(tag => {
                if (!tag.includes('>>')) return true;
                const [_, tagTarget] = tag.split('>>');
                return tagTarget.trim() !== target;
            });
            
            // Add the new relation
            tagList.push(`${relation}>>${target}`);
            
            return tagList.join(', ');
        },
    
        // Remove a relation from item tags
        removeRelationFromTags(tags, target) {
            if (!tags || !target) return tags;
            
            // Handle case where tags might be a JSON string
            let normalizedTags = tags;
            if (tags && typeof tags === 'string' && tags.trim().startsWith('[{')) {
                try {
                    const parsedTags = JSON.parse(tags);
                    if (Array.isArray(parsedTags)) {
                        normalizedTags = parsedTags.map(tag => tag.value || '').filter(t => t).join(', ');
                    }
                } catch (err) {
                    console.warn("Failed to parse tags JSON:", err);
                }
            }
            
            const tagList = normalizedTags.split(',')
                .map(tag => tag.trim())
                .filter(tag => {
                    if (!tag.includes('>>')) return true;
                    const [_, tagTarget] = tag.split('>>');
                    return tagTarget.trim() !== target;
                });
            
            return tagList.join(', ');
        },
        
        // Update references to a renamed item in relations
        updateRelationReferences(items, oldTitle, newTitle) {
            if (!items || !Array.isArray(items) || !oldTitle || !newTitle) return false;
            
            let updatesCount = 0;
            
            const updateItemRelations = (item) => {
                if (item.tags) {
                    const relations = this.getRelationsFromTags(item.tags);
                    let updated = false;
                    
                    // Check if this item has relations to the old title
                    relations.forEach(rel => {
                        if (rel.target === oldTitle) {
                            updated = true;
                            updatesCount++;
                        }
                    });
                    
                    // Update tags if needed
                    if (updated) {
                        // Replace all occurrences of the old title in relation tags
                        let updatedTags = [];
                        item.tags.split(',').forEach(tag => {
                            const trimmedTag = tag.trim();
                            if (this.isRelationTag(trimmedTag)) {
                                const [relation, target] = trimmedTag.split('>>');
                                if (target.trim() === oldTitle) {
                                    updatedTags.push(`${relation}>>${newTitle}`);
                                } else {
                                    updatedTags.push(trimmedTag);
                                }
                            } else {
                                updatedTags.push(trimmedTag);
                            }
                        });
                        item.tags = updatedTags.join(', ');
                    }
                }
                
                // Recursively process children
                if (item.items && item.items.length > 0) {
                    item.items.forEach(updateItemRelations);
                }
            };
            
            items.forEach(updateItemRelations);
            return updatesCount;
        },
        
    // Render relations for display
    renderRelationTags(relations) {
        if (!relations || relations.length === 0) {
            return '<div class="alert alert-info">No relations defined</div>';
        }
        
        let html = '<div class="relation-tags">';
        
        relations.forEach(rel => {
            const relType = rel.relation;
            const relInfo = RELATION_TYPES[relType] || { 
                icon: 'bi-link', 
                label: relType, 
                level: ''
            };
            
            // Check for numeric value in relation name
            const colorClass = this.getRelationColorClass(relType);
            
            // Use either standard level class or new color class
            let levelClass;
            if (colorClass) {
                levelClass = colorClass;
            } else {
                levelClass = relInfo.level ? `relation-${relInfo.level}` : '';
            }
            
            html += `
            <span class="relation-tag ${levelClass}" data-relation="${relType}>>${rel.target}">
                <i class="bi ${relInfo.icon}"></i>
                ${relInfo.label}:
                <span class="relation-target ms-1">${rel.target}</span>
                <button type="button" class="btn-close ms-2" style="font-size: 0.5rem;" data-relation="${relType}>>${rel.target}" aria-label="Remove"></button>
            </span>`;
        });
        
        html += '</div>';
        return html;
    },
    
        // Update related items in info panel
        updateRelatedItems(items, currentItem) {
            if (!currentItem) return;
            
            const relatedItemsContainer = document.getElementById('related-items');
            const relatedItemsList = document.getElementById('related-items-list');
            
            if (!relatedItemsContainer || !relatedItemsList) return;
            
            const relatedItems = this.findRelatedItems(items, currentItem);
            
            if (relatedItems.length > 0) {
                relatedItemsContainer.classList.remove('d-none');
                relatedItemsList.innerHTML = '';
                
                relatedItems.forEach(item => {
                    const itemElement = document.createElement('a');
                    itemElement.href = `#${item.id}`;
                    itemElement.className = 'list-group-item list-group-item-action';
                    itemElement.dataset.id = item.id;
                    itemElement.textContent = item.title;
                    
                    itemElement.addEventListener('click', (e) => {
                        e.preventDefault();
                        window.app?.setCurrentItemId(item.id);
                        infoPanel.hide();
                    });
                    
                    relatedItemsList.appendChild(itemElement);
                });
            } else {
                relatedItemsContainer.classList.add('d-none');
            }
        },
        
        // Find items related to the current item
        findRelatedItems(items, currentItem) {
            if (!items || !Array.isArray(items) || !currentItem) return [];
            
            const relatedItems = [];
            const titleWords = currentItem.title.toLowerCase().split(/\s+/).filter(word => word.length > 3);
            
            const processItems = (items) => {
                items.forEach(item => {
                    // Skip self-references
                    if (item.id === currentItem.id) return;
                    
                    // Check explicit relations in tags
                    if (item.tags) {
                        const relations = this.getRelationsFromTags(item.tags);
                        const isRelated = relations.some(rel => rel.target === currentItem.title);
                        
                        if (isRelated) {
                            relatedItems.push(item);
                            return;
                        }
                        
                        // Check tag matches
                        const tags = item.tags.split(',').map(tag => tag.trim())
                            .filter(tag => !tag.startsWith('type::') && !tag.includes('>>'));
                        
                        const matchesTags = titleWords.some(word => tags.some(tag => tag.toLowerCase().includes(word)));
                        
                        if (matchesTags) {
                            relatedItems.push(item);
                            return;
                        }
                    }
                    
                    // Check for title similarity
                    const itemTitle = item.title.toLowerCase();
                    const matchesTitle = titleWords.some(word => itemTitle.includes(word));
                    
                    if (matchesTitle) {
                        relatedItems.push(item);
                    }
                    
                    // Process children recursively
                    if (item.items && item.items.length > 0) {
                        processItems(item.items);
                    }
                });
            };
            
            processItems(items);
            
            // Check relations from current item to others
            if (currentItem.tags) {
                const relations = this.getRelationsFromTags(currentItem.tags);
                
                relations.forEach(rel => {
                    const targetItem = this.findItemByTitle(items, rel.target);
                    if (targetItem && !relatedItems.some(item => item.id === targetItem.id)) {
                        relatedItems.push(targetItem);
                    }
                });
            }
            
            return relatedItems;
        },
        
        // Toggle sidebar visibility
        toggleSidebar(collapse) {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            const mainHeader = document.getElementById('main-header');
            const expandSidebarBtn = document.getElementById('expand-sidebar-btn');
            
            if (collapse) {
                sidebar.classList.add('collapsed');
                mainContent.classList.add('expanded');
                mainHeader.classList.add('expanded');
                expandSidebarBtn.classList.remove('d-none');
            } else {
                sidebar.classList.remove('collapsed');
                mainContent.classList.remove('expanded');
                mainHeader.classList.remove('expanded');
                expandSidebarBtn.classList.add('d-none');
            }
        },
    
        // Populate selectors for matrix editor
        populateItemSelectors(items) {
            const sourceSelect = document.getElementById('source-item-select');
            const targetSelect = document.getElementById('target-item-select');
            
            if (!sourceSelect || !targetSelect) return;
            
            // Clear existing options except the first
            sourceSelect.innerHTML = '<option value="">Select item for rows...</option>';
            targetSelect.innerHTML = '<option value="">Select item for columns...</option>';
            
            // Get all items with children
            const itemsWithChildren = [];
            
            const collectItemsWithChildren = (items, depth = 0, path = '') => {
                items.forEach(item => {
                    if (item.items && item.items.length > 0) {
                        const itemPath = path ? `${path} > ${item.title}` : item.title;
                        itemsWithChildren.push({ 
                            id: item.id, 
                            title: item.title,
                            path: itemPath,
                            depth
                        });
                        
                        collectItemsWithChildren(item.items, depth + 1, itemPath);
                    }
                });
            };
            
            collectItemsWithChildren(items);
            
            // Add options to selects
            itemsWithChildren.forEach(item => {
                const option = document.createElement('option');
                option.value = item.id;
                option.textContent = item.path;
                option.style.paddingLeft = `${item.depth * 10}px`;
                
                const targetOption = option.cloneNode(true);
                
                sourceSelect.appendChild(option);
                targetSelect.appendChild(targetOption);
            });
        },
    
        // Process a matrix based on source and target items - updated to use semicolons and filter type items
        processMatrix(items, sourceItemId, targetItemId, cellValues = "") {
            const sourceItem = this.findItemById(items, sourceItemId);
            const targetItem = this.findItemById(items, targetItemId);
            
            if (!sourceItem?.items || !targetItem?.items) return null;
            
            // Parse cell values if provided - using semicolons now instead of commas
            let validValues = [];
            if (cellValues && cellValues.trim()) {
                validValues = cellValues.split(';').map(v => v.trim()).filter(v => v);
            }
            
            // Build matrix - exclude items with type tags
            const matrix = {
                sourceItem,
                targetItem,
                rows: sourceItem.items
                    .filter(item => !item.tags || !item.tags.includes('type::'))
                    .map(item => ({ id: item.id, title: item.title, content: item.content })),
                columns: targetItem.items
                    .filter(item => !item.tags || !item.tags.includes('type::'))
                    .map(item => ({ id: item.id, title: item.title, content: item.content })),
                cellValues: validValues,
                data: {}
            };
            
            // Initialize data
            sourceItem.items
                .filter(item => !item.tags || !item.tags.includes('type::'))
                .forEach(row => {
                    if (!matrix.data[row.id]) {
                        matrix.data[row.id] = {};
                    }
                    
                    // Get relations from row to any target column
                    const relations = this.getRelationsFromTags(row.tags || '');
                    
                    targetItem.items
                        .filter(item => !item.tags || !item.tags.includes('type::'))
                        .forEach(col => {
                            // Find if there's a relation to this column
                            const relation = relations.find(rel => rel.target === col.title);
                            matrix.data[row.id][col.id] = relation ? relation.relation : '';
                        });
                });
            
            return matrix;
        },
    
        // Load matrix into the editor UI
        loadMatrixEditor(matrix) {
            if (!matrix) return;
            
            const container = document.getElementById('matrix-container');
            if (!container) return;
            
            // Clear container
            container.innerHTML = '';
            
            // Create HTML table
            const table = document.createElement('table');
            table.className = 'table table-bordered';
            
            // Create header row
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const cornerCell = document.createElement('th');
            
            headerRow.appendChild(cornerCell);
            
            // Add column headers with tooltips for content
            matrix.columns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col.title;
                th.dataset.id = col.id;
                th.dataset.content = col.content || '';
                th.dataset.bs = 'tooltip';
                th.title = col.content ? `${col.content.substring(0, 200)}${col.content.length > 200 ? '...' : ''}` : '';
                th.style.cursor = 'help';
                
                // Add mouse events for custom tooltip
                th.addEventListener('mouseenter', (e) => this.showMatrixCellTooltip(e, col));
                th.addEventListener('mouseleave', () => this.hideMatrixCellTooltip());
                
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body rows
            const tbody = document.createElement('tbody');
            
            matrix.rows.forEach(row => {
                const tr = document.createElement('tr');
                
                // Add row header with tooltip
                const rowHeader = document.createElement('th');
                rowHeader.textContent = row.title;
                rowHeader.dataset.id = row.id;
                rowHeader.dataset.content = row.content || '';
                rowHeader.dataset.bs = 'tooltip';
                rowHeader.title = row.content ? `${row.content.substring(0, 200)}${row.content.length > 200 ? '...' : ''}` : '';
                rowHeader.style.cursor = 'help';
                
                // Add mouse events for custom tooltip
                rowHeader.addEventListener('mouseenter', (e) => this.showMatrixCellTooltip(e, row));
                rowHeader.addEventListener('mouseleave', () => this.hideMatrixCellTooltip());
                
                tr.appendChild(rowHeader);
                
                matrix.columns.forEach(col => {
                    const td = document.createElement('td');
                    td.dataset.row = row.id;
                    td.dataset.col = col.id;
                    
                    // Determine if we use select or input based on cell values
                    if (matrix.cellValues && matrix.cellValues.length > 0) {
                        // Create selector with defined values
                        const select = document.createElement('select');
                        select.className = 'form-select form-select-sm';
                        
                        // Empty option
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = '--';
                        select.appendChild(emptyOption);
                        
                        // Custom cell values
                        matrix.cellValues.forEach(value => {
                            const option = document.createElement('option');
                            option.value = value;
                            option.textContent = value;
                            
                            if (matrix.data[row.id][col.id] === value) {
                                option.selected = true;
                            }
                            
                            select.appendChild(option);
                        });
                        
                        // Event listener for changes
                        select.addEventListener('change', (e) => {
                            matrix.data[row.id][col.id] = e.target.value;
                        });
                        
                        td.appendChild(select);
                    } else {
                        // Use a text input field
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'form-control form-control-sm';
                        input.value = matrix.data[row.id][col.id] || '';
                        
                        // Event listener for changes
                        input.addEventListener('input', (e) => {
                            matrix.data[row.id][col.id] = e.target.value;
                        });
                        
                        td.appendChild(input);
                    }
                    
                    tr.appendChild(td);
                });
                
                tbody.appendChild(tr);
            });
            
            table.appendChild(tbody);
            container.appendChild(table);
            
            // Store matrix in window for access when saving
            window.currentMatrix = matrix;
        },
        
        // Show tooltip for matrix cells
        showMatrixCellTooltip(event, item) {
            if (!item.content) return;
            
            const tooltip = document.getElementById('matrix-cell-tooltip');
            if (!tooltip) return;
            
            tooltip.innerHTML = `<strong>${item.title}</strong><br>${item.content.substring(0, 300)}${item.content.length > 300 ? '...' : ''}`;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY + 10) + 'px';
            
            this.matrixCellTooltip = tooltip;
        },
        
        // Hide tooltip for matrix cells
        hideMatrixCellTooltip() {
            if (this.matrixCellTooltip) {
                this.matrixCellTooltip.style.display = 'none';
            }
        },
    
        // Save matrix changes back to item tags
        saveMatrixChanges(matrix) {
            if (!matrix || !matrix.sourceItem || !matrix.targetItem) return false;
            
            // Update relations in each source item's tags
            matrix.sourceItem.items
                .filter(item => !item.tags || !item.tags.includes('type::'))
                .forEach(row => {
                    if (!row.id || !matrix.data[row.id]) return;
                    
                    // Start with existing tags
                    let tags = row.tags || '';
                    
                    // Remove any existing relations to target items
                    matrix.targetItem.items
                        .filter(item => !item.tags || !item.tags.includes('type::'))
                        .forEach(col => {
                            tags = this.removeRelationFromTags(tags, col.title);
                        });
                    
                    // Add new relations
                    matrix.targetItem.items
                        .filter(item => !item.tags || !item.tags.includes('type::'))
                        .forEach(col => {
                            const relation = matrix.data[row.id][col.id];
                            if (relation) {
                                tags = this.addRelationToTags(tags, relation, col.title);
                            }
                        });
                    
                    // Update row tags
                    row.tags = tags;
                });
            
            return true;
        },
    
        // Create heatmap visualization for matrix data - improved column labels and rotation
        createHeatmap(container, matrixItem, items) {
            if (!d3 || !container || !matrixItem) return null;
            
            // Clear the container
            container.innerHTML = '';
            
            // Extract source and target items from tags
            const tags = matrixItem.tags ? matrixItem.tags.split(',').map(tag => tag.trim()) : [];
            const sourceItemTag = tags.find(tag => tag.startsWith('source-item::'));
            const targetItemTag = tags.find(tag => tag.startsWith('target-item::'));
            const cellValuesTag = tags.find(tag => tag.startsWith('values::'));
            
            if (!sourceItemTag || !targetItemTag) {
                container.innerHTML = '<div class="alert alert-warning">Invalid matrix configuration: source or target item not specified</div>';
                return null;
            }
            
            // Extract source and target item titles
            const sourceItemTitle = sourceItemTag.split('::')[1];
            const targetItemTitle = targetItemTag.split('::')[1];
            
            // Find source and target items
            const sourceItem = this.findItemByTitle(items, sourceItemTitle);
            const targetItem = this.findItemByTitle(items, targetItemTitle);
            
            if (!sourceItem?.items || !targetItem?.items) {
                container.innerHTML = '<div class="alert alert-warning">Source or target items not found or contain no children</div>';
                return null;
            }
            
            // Create a wrapper div for horizontal scrolling
            const scrollContainer = document.createElement('div');
            scrollContainer.className = 'heatmap-container';
            container.appendChild(scrollContainer);
            
            // Create the heatmap data structure
            const heatmapData = [];
            
            // Get filtered items (exclude type items)
            const sourceItems = sourceItem.items.filter(item => !item.tags || !item.tags.includes('type::'));
            const targetItems = targetItem.items.filter(item => !item.tags || !item.tags.includes('type::'));
            
            // Generate data for heatmap
            sourceItems.forEach(sourceChild => {
                const rowData = {
                    row: sourceChild.title,
                    values: []
                };
                
                // Get all relations from this source item
                const relations = this.getRelationsFromTags(sourceChild.tags || '');
                
                // For each target item, check if there's a relation
                // For each target item, check if there's a relation
                targetItems.forEach(targetChild => {
                    const relation = relations.find(rel => rel.target === targetChild.title);
                    
                    // Convert relation to a numeric value for the heatmap using the mapping function
                    let value = 0;
                    if (relation) {
                        value = this.getNumericValueForRelation(relation.relation);
                    }
                    
                    rowData.values.push({
                        value: value,
                        relation: relation ? relation.relation : ''
                    });
                });
                
                heatmapData.push(rowData);
            });
            
            // Create columns array for the heatmap
            const columns = targetItems.map(item => item.title);
            
            // Check if we have data
            if (heatmapData.length === 0 || columns.length === 0) {
                container.innerHTML = '<div class="alert alert-warning">No valid data found for heatmap visualization</div>';
                return null;
            }
            
            // Set dimensions for heatmap
            const gridSize = 60;
            const width = Math.max(gridSize * columns.length + 250, 800);
            const height = gridSize * heatmapData.length + 200;
            
            // Create the SVG element
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("class", "heatmap-svg");
            
            // Color scale (using blues)
            const colorScale = d3.scaleSequential(d3.interpolateBlues)
                .domain([0, 9]); // Set domain to match our 9 levels
               
            // Setup margins for better column label placement
            const margin = {top: 150, right: 20, bottom: 20, left: 200};
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create a group for the main grid
            const mainGroup = svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);
             
            // Create tooltip
            const tooltip = d3.select("#d3-tooltip");
            
            // Add column labels with better rotation
            svg.selectAll(".colLabel")
                .data(columns)
                .join("text")
                .attr("class", "colLabel")
                .attr("x", 0)
                .attr("y", 0)
                .attr("transform", (d, i) => {
                    // Calculate center of the column for rotation
                    const x = margin.left + i * gridSize + gridSize / 2;
                    const y = margin.top - 10; // Position above the grid
                    return `translate(${x}, ${y}) rotate(-70)`;
                })
                .attr("text-anchor", "start")
                .style("font-size", "12px")
                .style("fill", "#333")
                .text(d => d) // No truncation needed due to rotation
                .append("title") // Add tooltip for full text
                .text(d => d);
            
            // Add row labels
            svg.selectAll(".rowLabel")
                .data(heatmapData)
                .join("text")
                .attr("class", "rowLabel")
                .attr("x", margin.left - 10)
                .attr("y", (d, i) => margin.top + i * gridSize + gridSize / 2)
                .attr("text-anchor", "end")
                .attr("alignment-baseline", "middle")
                .style("font-size", "13px")
                .style("fill", "#333")
                .text(d => d.row.length > 25 ? d.row.substring(0, 23) + '...' : d.row)
                .append("title") // Add tooltip with full text
                .text(d => d.row);
            
    // Create heatmap cells
    heatmapData.forEach((row, rowIndex) => {
        mainGroup.selectAll(`.cell-${rowIndex}`)
            .data(row.values)
            .join("rect")
            .attr("class", "cell")
            .attr("x", (d, colIndex) => colIndex * gridSize)
            .attr("y", rowIndex * gridSize)
            .attr("width", gridSize)
            .attr("height", gridSize)
            .attr("fill", d => {
                // If we have relation color, use it
                if (d.relation) {
                    const relationColor = Utils.getColorForRelation(d.relation);
                    if (relationColor) return relationColor;
                }
                // Otherwise use the standard color scale
                return colorScale(d.value);
            })
            .attr("stroke", "#fff")
            .attr("stroke-width", 1)
    
                    .on("mouseover", function(event, d) {
                        // Show tooltip
                        const relationLabels = {
                            'extremely-high': 'Extremely High',
                            'very-high': 'Very High',
                            'high': 'High',
                            'slightly-high': 'Slightly High',
                            'neutral': 'Neutral',
                            'slightly-low': 'Slightly Low',
                            'low': 'Low',
                            'very-low': 'Very Low',
                            'extremely-low': 'Extremely Low'
                        };
                        
                        tooltip.style("opacity", 1)
                            .html(`<strong>Value:</strong> ${d.relation ? relationLabels[d.relation] || d.relation : 'None'}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                            
                        // Highlight cell
                        d3.select(this).attr("stroke", "#333").attr("stroke-width", 2);
                    })
                    .on("mouseout", function() {
                        // Hide tooltip
                        tooltip.style("opacity", 0);
                        
                        // Restore cell appearance
                        d3.select(this).attr("stroke", "#fff").attr("stroke-width", 1);
                    });
                    
                // Add values inside cells
                mainGroup.selectAll(`.value-${rowIndex}`)
                    .data(row.values)
                    .join("text")
                    .attr("x", (d, colIndex) => colIndex * gridSize + gridSize / 2)
                    .attr("y", rowIndex * gridSize + gridSize / 2)
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "middle")
                    .text(d => d.value === 0 ? "" : d.value)
                    .style("font-size", "14px")
                    .style("fill", d => d.value > 4 ? "#fff" : "#000")  // White text for darker cells
                    .style("pointer-events", "none");  // Ensure text doesn't interfere with mouse events
            });
            
            // Append the SVG to the container
            scrollContainer.appendChild(svg.node());
            
            return svg.node();
        },
        
        // Create Sankey diagram from matrix data
        createSankeyDiagram(container, matrixItem, items) {
            if (!d3 || !container || !matrixItem) return null;
            
            // Clear the container
            container.innerHTML = '';
            
            // Extract source and target items from tags
            const tags = matrixItem.tags ? matrixItem.tags.split(',').map(tag => tag.trim()) : [];
            const sourceItemTag = tags.find(tag => tag.startsWith('source-item::'));
            const targetItemTag = tags.find(tag => tag.startsWith('target-item::'));
            
            if (!sourceItemTag || !targetItemTag) {
                container.innerHTML = '<div class="alert alert-warning">Invalid matrix configuration: source or target item not specified</div>';
                return null;
            }
            
            // Extract source and target item titles
            const sourceItemTitle = sourceItemTag.split('::')[1];
            const targetItemTitle = targetItemTag.split('::')[1];
            
            // Find source and target items
            const sourceItem = this.findItemByTitle(items, sourceItemTitle);
            const targetItem = this.findItemByTitle(items, targetItemTitle);
            
            if (!sourceItem?.items || !targetItem?.items) {
                container.innerHTML = '<div class="alert alert-warning">Source or target items not found or contain no children</div>';
                return null;
            }
            
            // Filter out items with type tags
            const filteredSourceItems = sourceItem.items.filter(item => !item.tags || !item.tags.includes('type::'));
            const filteredTargetItems = targetItem.items.filter(item => !item.tags || !item.tags.includes('type::'));
            
            // Create SVG element for the Sankey diagram
            const width = Math.max(800, container.clientWidth);
            const height = 500;
            
            const svg = d3.create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("class", "sankey-svg");
            
            // Create tooltip
            const tooltip = d3.select("#d3-tooltip");
            
            // Prepare Sankey diagram data
            const nodes = [];
            const links = [];
            
            // Add source nodes
            filteredSourceItems.forEach((item) => {
                nodes.push({ name: item.title });
            });
            
            // Add target nodes (offset by source item count)
            const sourceOffset = filteredSourceItems.length;
            filteredTargetItems.forEach((item) => {
                nodes.push({ name: item.title });
            });
            
            // Define relation intensity values
            const relationValues = {
                'extremely-high': 9,
                'very-high': 8,
                'high': 7,
                'slightly-high': 6,
                'neutral': 5,
                'slightly-low': 4,
                'low': 3,
                'very-low': 2,
                'extremely-low': 1,
                'related': 1,
                'depends': 1
            };
            
    // Create links from the matrix data
    filteredSourceItems.forEach((sourceChild, sourceIndex) => {
        // Get all relations from this source item's tags
        const relations = this.getRelationsFromTags(sourceChild.tags || '');
        
        filteredTargetItems.forEach((targetChild, targetIndex) => {
            // Look for relations to this target
            const relation = relations.find(rel => rel.target === targetChild.title);
            if (relation && relation.relation) {
                // Get value based on relation type using the mapping function
                const value = this.getNumericValueForRelation(relation.relation);
                
                // Check if the relation has a numeric value in parentheses
                const relationColor = this.getColorForRelation(relation.relation);
                
                links.push({
                    source: sourceIndex,
                    target: sourceOffset + targetIndex,
                    value: value,
                    type: relation.relation,
                    relationValue: value, // Store the actual value
                    relationColor: relationColor // Store the color if available
                });
            }
        });
    });
    
            // Check if we have valid data
            if (nodes.length === 0 || links.length === 0) {
                container.innerHTML = '<div class="alert alert-warning">No relationships found between source and target items</div>';
                return null;
            }
            
            // Create the Sankey diagram
            const sankey = d3.sankey()
                .nodeWidth(30)
                .nodePadding(20)
                .extent([[20, 20], [width - 20, height - 20]]);
            
            // Generate the Sankey layout
            const graph = sankey({
                nodes: nodes.map(d => Object.assign({}, d)),
                links: links.map(d => Object.assign({}, d))
            });
            
    // Add links
    svg.append("g")
        .selectAll("path")
        .data(graph.links)
        .join("path")
        .attr("class", "sankey-link")
        .attr("d", d3.sankeyLinkHorizontal())
        .attr("stroke", d => {
            // If we have a dynamic relation color, use it
            if (d.relationColor) {
                return d.relationColor;
            }
            
            // Otherwise, fall back to standard colors based on relation type
            if (d.type === 'extremely-high') return "#006E00";
            if (d.type === 'very-high') return "#17A217";
            if (d.type === 'high') return "#2CBA00";
            if (d.type === 'slightly-high') return "#64DC00";
            if (d.type === 'neutral') return "#808080";
            if (d.type === 'slightly-low') return "#FFC800";
            if (d.type === 'low') return "#FF9600";
            if (d.type === 'very-low') return "#FF6400";
            if (d.type === 'extremely-low') return "#FF0000";
            return "#6c757d"; // Default gray
        })
    
                .attr("stroke-width", d => Math.max(1, d.width))
                .attr("fill", "none")
                .attr("stroke-opacity", 0.5)
                .on("mouseover", function(event, d) {
                    // Show link info on hover with the actual relation value
                    d3.select(this).attr("stroke-opacity", 0.8);
                    tooltip.style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(`<strong>${d.source.name}</strong> >> <strong>${d.target.name}</strong><br/>
                              ${d.type} (Value: ${d.relationValue})`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("stroke-opacity", 0.5);
                    tooltip.style("opacity", 0);
                });
            
            // Add nodes
            const node = svg.append("g")
                .selectAll("g")
                .data(graph.nodes)
                .join("g")
                .attr("class", "sankey-node");
            
            // Add node rectangles
            node.append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
                .attr("fill-opacity", 0.8)
                .attr("stroke", "#555")
                .on("mouseover", function(event, d) {
                    // Highlight node on hover
                    d3.select(this).attr("fill-opacity", 1);
                    tooltip.style("opacity", 1)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px")
                        .html(`<strong>${d.name}</strong>`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("fill-opacity", 0.8);
                    tooltip.style("opacity", 0);
                });
            
            // Add node labels
            node.append("text")
                .attr("x", d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
                .text(d => d.name)
                .style("font-size", "12px")
                .style("font-weight", "bold");
            
            // Append the SVG to the container
            container.appendChild(svg.node());
            
            return svg.node();
        }
    };
    
    /**
     * Main context provider for application data
     */
    const DataContext = React.createContext(null);
    
    const DataProvider = ({ children }) => {
        // Core state
        const [items, setItems] = React.useState([]);
        const [filteredItems, setFilteredItems] = React.useState([]);
        const [documentTitle, setDocumentTitle] = React.useState("Untitled Document");
        
        // UI state
        const [activeTags, setActiveTags] = React.useState(['all']);
        const [currentItemId, setCurrentItemId] = React.useState(null);
        const [expandedItems, setExpandedItems] = React.useState({});
        const [navExpandedItems, setNavExpandedItems] = React.useState({});
        const [isInfoPanelOpen, setIsInfoPanelOpen] = React.useState(false);
        
        // Additional state
        const [chatMessages, setChatMessages] = React.useState([]);
        const [suggestedItems, setSuggestedItems] = React.useState([]);
        const [markdownContent, setMarkdownContent] = React.useState("");
        const [originalFilename, setOriginalFilename] = React.useState("");
        
        // Toggle tag filter
        const toggleTagFilter = React.useCallback((tag) => {
            setActiveTags(prev => {
                if (tag === 'all') return ['all'];
                
                if (prev.includes(tag)) {
                    const newTags = prev.filter(t => t !== tag);
                    return newTags.length === 0 || (newTags.length === 1 && newTags[0] === 'all') 
                        ? ['all'] 
                        : newTags;
                } else {
                    return [...prev.filter(t => t !== 'all'), tag];
                }
            });
        }, []);
        
        // Initialize app from local storage
        React.useEffect(() => {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    setItems(parsedData.items || []);
                    setFilteredItems(parsedData.items || []);
                    setDocumentTitle(parsedData.title || "Untitled Document");
                    
                    const expanded = {};
                    const navExpanded = {};
                    const processItems = (itemList, depth = 0) => {
                        if (!itemList) return;
                        itemList.forEach(item => {
                            if (item && item.id) {
                                expanded[item.id] = true;
                                // Only expand top-level items in navigation by default
                                navExpanded[item.id] = depth === 0;
                                if (item.items && item.items.length > 0) {
                                    processItems(item.items, depth + 1);
                                }
                            }
                        });
                    };
                    processItems(parsedData.items || []);
                    setExpandedItems(expanded);
                    setNavExpandedItems(navExpanded);
                } catch (error) {
                    console.error("Failed to load saved data:", error);
                }
            }
        }, []);
        
        // Save to local storage and update filters when items change
        React.useEffect(() => {
            if (items.length > 0) {
                const dataToSave = {
                    title: documentTitle,
                    items: items
                };
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            }
    
            if (activeTags.includes('all')) {
                setFilteredItems(items);
            } else {
                setFilteredItems(Utils.filterItemsByTags(items, activeTags));
            }
    
            updateDocumentNavigation();
            updateTagFilters();
        }, [items, documentTitle, navExpandedItems]);
        
        // Update tag filters
        React.useEffect(() => {
            if (activeTags.includes('all')) {
                setFilteredItems(items);
            } else {
                const filterModeSelect = document.getElementById('tag-filter-mode');
                const showSubitemsCheckbox = document.getElementById('show-subitems-checkbox');
                
                const filterMode = filterModeSelect ? filterModeSelect.value : 'OR';
                const showSubitems = showSubitemsCheckbox ? showSubitemsCheckbox.checked : true;
                
                setFilteredItems(Utils.filterItemsByTags(items, activeTags, filterMode, showSubitems));
            }
            
            const tagFilterBtn = document.getElementById('tag-filter-btn');
            if (tagFilterBtn) {
                if (activeTags.includes('all')) {
                    tagFilterBtn.classList.remove('filtering');
                } else {
                    tagFilterBtn.classList.add('filtering');
                }
            }
            
            updateDocumentNavigation();
        }, [activeTags]);
    
        // Update sidebar state when classes change
        React.useEffect(() => {
            const mainContent = document.getElementById('main-content');
            const mainHeader = document.getElementById('main-header');
            const sidebar = document.getElementById('sidebar');
            const expandSidebarBtn = document.getElementById('expand-sidebar-btn');
    
            if (window.MutationObserver) {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach(mutation => {
                        if (mutation.attributeName === 'class') {
                            const isCollapsed = sidebar.classList.contains('collapsed');
                            if (isCollapsed) {
                                mainContent.classList.add('expanded');
                                mainHeader.classList.add('expanded');
                                expandSidebarBtn.classList.remove('d-none');
                            } else {
                                mainContent.classList.remove('expanded');
                                mainHeader.classList.remove('expanded');
                                expandSidebarBtn.classList.add('d-none');
                            }
                        }
                    });
                });
                
                observer.observe(sidebar, { attributes: true });
                return () => observer.disconnect();
            }
        }, []);
        
        // Update related items when current item changes
        React.useEffect(() => {
            if (currentItemId) {
                const currentItem = Utils.findItemById(items, currentItemId);
                if (currentItem) {
                    Utils.updateRelatedItems(items, currentItem);
                }
            }
        }, [currentItemId, items]);
        
        // Update tag filters in UI
        const updateTagFilters = React.useCallback(() => {
            const tagFiltersContainer = document.getElementById('tag-filters');
            if (!tagFiltersContainer) return;
            
            const allTags = Utils.extractAllTags(items);
            
            tagFiltersContainer.innerHTML = '';
            
            if (allTags.length === 0) {
                tagFiltersContainer.innerHTML = '<div class="text-muted">No tags available</div>';
                return;
            }
            
            const allButton = document.createElement('button');
            allButton.className = `btn ${activeTags.includes('all') ? 'btn-secondary' : 'btn-outline-secondary'} w-100 mb-2`;
            allButton.textContent = 'All Tags';
            allButton.addEventListener('click', () => {
                toggleTagFilter('all');
            });
            tagFiltersContainer.appendChild(allButton);
            
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'd-flex flex-wrap gap-1';
            tagFiltersContainer.appendChild(tagsContainer);
            
            allTags.forEach(tag => {
                const button = document.createElement('button');
                button.className = `btn btn-sm ${activeTags.includes(tag) ? 'btn-secondary' : 'btn-outline-secondary'} me-1 mb-1`;
                button.textContent = tag;
                button.addEventListener('click', () => {
                    toggleTagFilter(tag);
                });
                tagsContainer.appendChild(button);
            });
            
            // Add event listeners for filter mode and subitem checkbox
            const filterModeSelect = document.getElementById('tag-filter-mode');
            const showSubitemsCheckbox = document.getElementById('show-subitems-checkbox');
            
            if (filterModeSelect && showSubitemsCheckbox) {
                // Set initial values from localStorage if available
                const savedFilterMode = localStorage.getItem('tag-filter-mode') || 'OR';
                const savedShowSubitems = localStorage.getItem('show-subitems') !== 'false';
                
                filterModeSelect.value = savedFilterMode;
                showSubitemsCheckbox.checked = savedShowSubitems;
                
                filterModeSelect.addEventListener('change', () => {
                    const mode = filterModeSelect.value;
                    localStorage.setItem('tag-filter-mode', mode);
                    if (!activeTags.includes('all')) {
                        // Apply the filter with the new mode
                        const showSubitems = showSubitemsCheckbox.checked;
                        setFilteredItems(Utils.filterItemsByTags(items, activeTags, mode, showSubitems));
                    }
                });
                
                showSubitemsCheckbox.addEventListener('change', () => {
                    const showSubitems = showSubitemsCheckbox.checked;
                    localStorage.setItem('show-subitems', showSubitems);
                    if (!activeTags.includes('all')) {
                        // Apply the filter with the subitem setting
                        const mode = filterModeSelect.value;
                        setFilteredItems(Utils.filterItemsByTags(items, activeTags, mode, showSubitems));
                    }
                });
            }
        }, [items, activeTags, toggleTagFilter]);
        
        // Update document navigation in UI
        const updateDocumentNavigation = React.useCallback(() => {
            const navContainer = document.getElementById('document-navigation');
            if (navContainer) {
                const itemContainers = document.querySelectorAll('.item-container');
                itemContainers.forEach(container => {
                    const id = container.dataset.id;
                    if (id) {
                        container.id = id;
                    }
                });
                
                const itemsToDisplay = activeTags.includes('all') ? items : filteredItems;
                navContainer.innerHTML = Utils.buildDocumentNavigationHtml(itemsToDisplay, currentItemId, navExpandedItems);
                
                navContainer.querySelectorAll('[id^="nav-collapse-"]').forEach(collapse => {
                    new bootstrap.Collapse(collapse, { toggle: false });
                });
                
                Utils.attachNavigationHandlers();
            }
        }, [items, filteredItems, activeTags, currentItemId, navExpandedItems]);
        
        // Update navigation when dependencies change
        React.useEffect(() => {
            updateDocumentNavigation();
        }, [updateDocumentNavigation]);
        
        // Update tag filters when dependencies change
        React.useEffect(() => {
            updateTagFilters();
        }, [updateTagFilters]);
        
        // Toggle navigation item expansion
        const toggleNavExpansion = React.useCallback((id, isExpanded) => {
            setNavExpandedItems(prev => ({...prev, [id]: isExpanded}));
        }, []);
        
        // Scroll to an item by ID - updated to scroll to top instead of center
        const scrollToItem = React.useCallback((itemId) => {
            const itemElement = document.getElementById(itemId);
            if (itemElement) {
                let current = itemId;
                while (current) {
                    const parent = Utils.findParentOfItem(items, current);
                    if (parent && parent.id) {
                        setExpandedItems(prev => ({...prev, [parent.id]: true}));
                        current = parent.id;
                    } else {
                        current = null;
                    }
                }
                
                setTimeout(() => {
                    // Use 'start' instead of 'center' for block
                    itemElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start',
                        inline: 'nearest'
                    });
                }, 100);
            }
        }, [items, setExpandedItems]);
        
        // Fetch markdown content for info panel
        const fetchMarkdownContent = React.useCallback(async (itemTitle) => {
            try {
                const path = Utils.getLocalMarkdownPath(itemTitle);
                
                const response = await fetch(path);
                
                if (!response.ok) {
                    throw new Error(`Error loading file: ${response.status}`);
                }
                
                const text = await response.text();
                setMarkdownContent(text || "No description available for this item.");
                
                const infoPanelContent = document.getElementById('info-panel-content');
                if (infoPanelContent) {
                    infoPanelContent.innerHTML = Utils.renderMarkdown(text);
                }
                
                return text;
            } catch (error) {
                console.log(`Info file not found for: ${itemTitle} - This is expected behavior.`);
                const fallbackContent = `<div class="alert alert-info">
                    <strong>No information available for "${itemTitle}"</strong><br><br>
                    <p>This is normal if you haven't created info files yet.</p>
                    <p>To add information, create a markdown file at this path: <code>${Utils.getLocalMarkdownPath(itemTitle)}</code></p>
                </div>`;
                
                setMarkdownContent(fallbackContent);
                
                const infoPanelContent = document.getElementById('info-panel-content');
                if (infoPanelContent) {
                    infoPanelContent.innerHTML = fallbackContent;
                }
                
                return fallbackContent;
            }
        }, []);
        
        // Reorder items (for drag-and-drop)
        const reorderItems = React.useCallback((sourceId, targetId, newIndex) => {
            if (!sourceId) return;
    
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    
                    // Handle top-level reordering
                    if (!targetId) {
                        for (let i = 0; i < newItems.length; i++) {
                            if (newItems[i].id === sourceId) {
                                const [movedItem] = newItems.splice(i, 1);
                                newItems.splice(newIndex, 0, movedItem);
                                return newItems;
                            }
                        }
                    }
                    
                    // Handle reordering within a parent
                    const findAndReorder = (items) => {
                        for (const item of items) {
                            if (item.id === targetId && item.items) {
                                for (let i = 0; i < item.items.length; i++) {
                                    if (item.items[i].id === sourceId) {
                                        const [movedItem] = item.items.splice(i, 1);
                                        item.items.splice(newIndex, 0, movedItem);
                                        return true;
                                    }
                                }
                            }
                            
                            if (item.items && item.items.length > 0) {
                                if (findAndReorder(item.items)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    
                    findAndReorder(newItems);
                    return newItems;
                } catch (error) {
                    console.error("Error during item reordering:", error);
                    return prevItems;
                }
            });
        }, []);
        
        // Add a new item with UUID approach
        const addItem = React.useCallback((newItem, parentId = null) => {
            if (!newItem.title) {
                Utils.showAlert("Item title is required", "danger");
                return false;
            }
    
            // Always generate a new unique ID
            if (!newItem.id) {
                newItem.id = Utils.generateItemId();
            }
            
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    const success = Utils.addItem(newItems, newItem, parentId);
                    
                    if (!success) {
                        throw new Error("Failed to add item");
                    }
                    
                    return newItems;
                } catch (err) {
                    console.error("Error adding item:", err);
                    Utils.showAlert(`Error adding item: ${err.message}`, "danger");
                    return prevItems;
                }
            });
            
            // Expand parent item if adding a child
            if (parentId) {
                setExpandedItems(prev => ({...prev, [parentId]: true}));
            }
            
            Utils.showAlert(`Item "${newItem.title}" has been added.`, "success");
            return true;
        }, []);
        
        // Check if item title is referenced in relations and offer to update
        const checkRelationReferences = React.useCallback((oldTitle, newTitle, updatedItem, callback) => {
            if (oldTitle === newTitle || !oldTitle || !newTitle) {
                // No change or invalid titles
                if (callback) callback(false);
                return;
            }
            
            // Setup the confirmation modal
            document.getElementById('old-title-ref').textContent = oldTitle;
            document.getElementById('new-title-ref').textContent = newTitle;
            
            const modal = new bootstrap.Modal(document.getElementById('update-relations-modal'));
            
            // Setup handlers
            const confirmBtn = document.getElementById('confirm-update-btn');
            const skipBtn = document.getElementById('skip-update-btn');
            
            const confirmHandler = () => {
                // Update all references
                const updateCount = Utils.updateRelationReferences(items, oldTitle, newTitle);
                
                // Complete the item update with the callback
                if (callback) callback(true, updateCount);
                
                // Cleanup
                modal.hide();
                confirmBtn.removeEventListener('click', confirmHandler);
                skipBtn.removeEventListener('click', skipHandler);
            };
            
            const skipHandler = () => {
                // Complete the item update without updating references
                if (callback) callback(false);
                
                // Cleanup
                modal.hide();
                confirmBtn.removeEventListener('click', confirmHandler);
                skipBtn.removeEventListener('click', skipHandler);
            };
            
            // Attach event handlers
            confirmBtn.addEventListener('click', confirmHandler);
            skipBtn.addEventListener('click', skipHandler);
            
            // Show the modal
            modal.show();
        }, [items]);
        
        // Update an existing item - with reference updating
        const updateItem = React.useCallback((updatedItem) => {
            if (!updatedItem || !updatedItem.id) {
                Utils.showAlert("Cannot update: Invalid item data", "danger");
                return false;
            }
            
            // Save scroll position before update
            Utils.saveScrollPosition();
            
            // Find original item to check title
            const originalItem = Utils.findItemById(items, updatedItem.id);
            if (originalItem && originalItem.title !== updatedItem.title) {
                // Title has changed, check for references
                checkRelationReferences(originalItem.title, updatedItem.title, updatedItem, (updatedReferences, count) => {
                    if (updatedReferences) {
                        Utils.showAlert(`Updated ${count} reference${count !== 1 ? 's' : ''} to the renamed item`, "success");
                    }
                    
                    // Perform the update
                    performItemUpdate(updatedItem);
                });
            } else {
                // No title change or no original item found
                performItemUpdate(updatedItem);
            }
            
            return true;
        }, [items, checkRelationReferences]);
        
        // Helper for updating an item
        const performItemUpdate = React.useCallback((updatedItem) => {
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    
                    // Find and update item by ID (which never changes)
                    const findAndUpdateItem = (items) => {
                        for (let i = 0; i < items.length; i++) {
                            if (items[i].id === updatedItem.id) {
                                // Store any children from the existing item
                                const children = items[i].items || [];
                                
                                // Replace the entire item
                                items[i] = {...updatedItem};
                                
                                // Preserve children if not provided in the update
                                if (!items[i].items || items[i].items.length === 0) {
                                    items[i].items = children;
                                }
                                
                                return true;
                            }
                            
                            // Recursively search in children
                            if (items[i].items && items[i].items.length > 0) {
                                if (findAndUpdateItem(items[i].items)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    
                    const updated = findAndUpdateItem(newItems);
                    
                    if (!updated) {
                        console.warn(`Item with ID ${updatedItem.id} not found in current items`);
                        return prevItems;
                    }
                    
                    return newItems;
                } catch (err) {
                    console.error("Error updating item:", err);
                    Utils.showAlert(`Error updating item: ${err.message}`, "danger");
                    return prevItems;
                }
            });
            
            // Restore scroll position after update with a slight delay
            Utils.restoreScrollPosition();
            
            Utils.showAlert(`Item "${updatedItem.title}" has been updated.`, "success");
        }, []);
        
        // Remove an item
        const removeItem = React.useCallback((id) => {
            if (!id) {
                Utils.showAlert("Cannot delete: Item ID is missing", "danger");
                return false;
            }
            
            setItems(prevItems => {
                try {
                    const newItems = JSON.parse(JSON.stringify(prevItems));
                    const removed = Utils.removeItemById(newItems, id);
                    
                    if (!removed) {
                        console.warn(`Item with ID ${id} not found for deletion`);
                    }
                    
                    return newItems;
                } catch (err) {
                    console.error("Error removing item:", err);
                    return prevItems;
                }
            });
            
            Utils.showAlert("Item has been deleted.", "success");
            return true;
        }, []);
        
        // Clear the document
        const clearDocument = React.useCallback(() => {
            setItems([]);
            setFilteredItems([]);
            setDocumentTitle("Untitled Document");
            setCurrentItemId(null);
            setExpandedItems({});
            setNavExpandedItems({});
            setChatMessages([]);
            setSuggestedItems([]);
            setOriginalFilename("");
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            Utils.showAlert("Document has been cleared.", "success");
        }, []);
        
        // Import a document with UUID generation
        const importDocument = React.useCallback((data, filename = "") => {
            setChatMessages([]);
            setSuggestedItems([]);
            setCurrentItemId(null);
            
            if (!data || !data.items || !Array.isArray(data.items)) {
                Utils.showAlert("Invalid document format. Missing items array.", "danger");
                return false;
            }
            
            // Generate new UUIDs for all items
            const generateIds = (items) => {
                if (!items) return;
                
                for (const item of items) {
                    item.id = Utils.generateItemId();
                    
                    if (item.items && item.items.length > 0) {
                        generateIds(item.items);
                    }
                }
            };
            
            // Generate all new IDs
            generateIds(data.items);
            
            setItems(data.items);
            setFilteredItems(data.items);
            setActiveTags(['all']);
            
            if (filename) {
                // Remove timestamp from filename if present (format: YYYY-MM-DD-HH-MM-SS)
                const filenameWithoutExtension = filename.replace(/\.(json)$/, '')
                                                        .replace(/_\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}$/, '');
                setDocumentTitle(filenameWithoutExtension);
                setOriginalFilename(filenameWithoutExtension);
            } else {
                setDocumentTitle(data.title || "Imported Document");
            }
            
            const expanded = {};
            const navExpanded = {};
            
            const processItems = (itemList, depth = 0) => {
                if (!itemList) return;
                itemList.forEach(item => {
                    if (item && item.id) {
                        expanded[item.id] = true;
                        navExpanded[item.id] = depth === 0;
                        
                        if (item.items && item.items.length > 0) {
                            processItems(item.items, depth + 1);
                        }
                    }
                });
            };
            
            processItems(data.items);
            
            setExpandedItems(expanded);
            setNavExpandedItems(navExpanded);
            
            setTimeout(() => {
                updateDocumentNavigation();
                updateTagFilters();
            }, 100);
            
            Utils.showAlert("Document imported successfully.", "success");
            return true;
        }, [updateDocumentNavigation, updateTagFilters]);
        
        // Toggle item expansion in UI
        const toggleItemExpansion = React.useCallback((id) => {
            setExpandedItems(prev => ({...prev, [id]: !prev[id]}));
        }, []);
        
        // Open matrix editor in a modal
        const openMatrixEditor = React.useCallback((matrixItem = null) => {
            if (items.length === 0) {
                Utils.showAlert("No items to create matrix with", "warning");
                return;
            }
    
            const modal = new bootstrap.Modal(document.getElementById('matrix-editor-modal'));
            
            // Populate source and target selectors
            Utils.populateItemSelectors(items);
            
            // Clear matrix container
            document.getElementById('matrix-container').innerHTML = 
                '<div class="alert alert-info">Select source and target items to build the matrix</div>';
            
            // Clear current matrix
            window.currentMatrix = null;
            
            // If we're editing an existing matrix item
            if (matrixItem) {
                // Extract source and target items from tags
                const tags = matrixItem.tags ? matrixItem.tags.split(',').map(tag => tag.trim()) : [];
                const sourceItemTag = tags.find(tag => tag.startsWith('source-item::'));
                const targetItemTag = tags.find(tag => tag.startsWith('target-item::'));
                const valuesTag = tags.find(tag => tag.startsWith('values::'));
                
                if (sourceItemTag && targetItemTag) {
                    // Extract IDs
                    const sourceItemTitle = sourceItemTag.split('::')[1];
                    const targetItemTitle = targetItemTag.split('::')[1];
                    
                    // Find source and target items by title
                    const sourceItem = Utils.findItemByTitle(items, sourceItemTitle);
                    const targetItem = Utils.findItemByTitle(items, targetItemTitle);
                    
                    if (sourceItem && targetItem) {
                        // Set select values
                        document.getElementById('source-item-select').value = sourceItem.id;
                        document.getElementById('target-item-select').value = targetItem.id;
                        
                        // Set cell values if present
                        const cellValuesInput = document.getElementById('matrix-cell-values');
                        if (valuesTag) {
                            cellValuesInput.value = valuesTag.split('::')[1];
                        } else {
                            cellValuesInput.value = '';
                        }
                        
                        // Create and load the matrix
                        const cellValues = cellValuesInput.value;
                        const matrix = Utils.processMatrix(items, sourceItem.id, targetItem.id, cellValues);
                        
                        if (matrix) {
                            Utils.loadMatrixEditor(matrix);
                        }
                    }
                }
            }
            
            // Load matrix button handler
            document.getElementById('load-matrix-btn').onclick = () => {
                const sourceId = document.getElementById('source-item-select').value;
                const targetId = document.getElementById('target-item-select').value;
                const cellValues = document.getElementById('matrix-cell-values').value;
                
                if (!sourceId || !targetId) {
                    Utils.showAlert("Please select both source and target items", "warning");
                    return;
                }
                
                const matrix = Utils.processMatrix(items, sourceId, targetId, cellValues);
                if (!matrix) {
                    Utils.showAlert("Could not build matrix with selected items", "warning");
                    return;
                }
                
                Utils.loadMatrixEditor(matrix);
            };
            
            // Save matrix button handler
            document.getElementById('save-matrix-btn').onclick = () => {
                if (!window.currentMatrix) {
                    Utils.showAlert("No matrix data to save", "warning");
                    return;
                }
                
                // If editing an existing matrix item, update its tags
                if (matrixItem) {
                    const sourceItem = window.currentMatrix.sourceItem;
                    const targetItem = window.currentMatrix.targetItem;
                    const cellValues = document.getElementById('matrix-cell-values').value;
                    
                    // Create separate tags for normal tags and special matrix tags
                    const regularTags = matrixItem.tags ? 
                        matrixItem.tags.split(',')
                            .map(tag => tag.trim())
                            .filter(tag => !tag.startsWith('source-item::') && 
                                           !tag.startsWith('target-item::') && 
                                           !tag.startsWith('values::') &&
                                           !tag.startsWith('type::'))
                            .join(', ') : '';
                    
                    // Build new tags
                    let newTags = 'type::matrix';
                    newTags += `, source-item::${sourceItem.title}`;
                    newTags += `, target-item::${targetItem.title}`;
                    
                    if (cellValues.trim()) {
                        newTags += `, values::${cellValues.trim()}`;
                    }
                    
                    if (regularTags) {
                        newTags += ', ' + regularTags;
                    }
                    
                    // Update the item
                    matrixItem.tags = newTags;
                    updateItem(matrixItem);
                }
                
                const success = Utils.saveMatrixChanges(window.currentMatrix);
                if (success) {
                    Utils.showAlert("Matrix saved successfully", "success");
                    // Update the state to trigger UI refresh
                    setItems([...items]);
                    modal.hide();
                } else {
                    Utils.showAlert("Failed to save matrix", "danger");
                }
            };
            
            modal.show();
        }, [items, updateItem]);
        
        // Send message to AI Assistant
        const sendChatMessage = React.useCallback(async (message) => {
            if (!message.trim()) return;
            
            const chatLoading = document.getElementById('chat-loading');
            if (chatLoading) {
                chatLoading.classList.remove('d-none');
            }
            
            setChatMessages(prev => [...prev, { text: message, sender: 'user' }]);
            
            try {
                const currentItem = Utils.findItemById(items, currentItemId);
                if (!currentItem) {
                    throw new Error("No item selected for context");
                }
                
                const sessionId = `strudol-session-${Date.now()}`;
                
                // Create a complete representation of the current item and its subitems
                const prepareItemWithSubitems = (item) => {
                    if (!item) return null;
                    
                    // Create a clean copy to avoid circular references
                    const cleanItem = {
                        id: item.id,
                        title: item.title,
                        content: item.content || "",
                        tags: item.tags || "",
                        items: []
                    };
                    
                    // Recursively add all subitems
                    if (item.items && Array.isArray(item.items)) {
                        cleanItem.items = item.items.map(subitem => prepareItemWithSubitems(subitem));
                    }
                    
                    return cleanItem;
                };
    
                // Get the complete current item with all its subitems
                const completeItem = prepareItemWithSubitems(currentItem);
    
                // Convert to JSON string for sectionContent
                const completeItemJSON = JSON.stringify(completeItem, null, 2);
    
                const payload = {
                    question: message,
                    sectionId: currentItem.id,
                    sectionTitle: currentItem.title,
                    // Include the complete JSON representation of current item and all subitems
                    sectionContent: completeItemJSON,
                    context_string: `This question is about the ${currentItem.title} item of the document.
                        The user is asking: ${message}`,
                    // Include full items context 
                    context: { 
                        items,
                        currentItem: completeItem
                    },
                    sessionId
                };
                                
                const response = await fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
                
                const responseData = await response.json();
                
                if (Array.isArray(responseData) && responseData.length > 0) {
                    const firstResponse = responseData[0];
                    
                    if (firstResponse.message) {
                        setChatMessages(prev => [...prev, { 
                            text: firstResponse.message, 
                            sender: 'chatbot' 
                        }]);
                    }
                    
                    if (firstResponse.suggestedItems && 
                        firstResponse.suggestedItems.items && 
                        Array.isArray(firstResponse.suggestedItems.items)) {
                        
                        processSuggestedItems(firstResponse.suggestedItems.items, currentItem);
                    }
                } else if (responseData.message) {
                    setChatMessages(prev => [...prev, { 
                        text: responseData.message, 
                        sender: 'chatbot' 
                    }]);
                    
                    if (responseData.suggestedItems && 
                        responseData.suggestedItems.items && 
                        Array.isArray(responseData.suggestedItems.items)) {
                        
                        processSuggestedItems(responseData.suggestedItems.items, currentItem);
                    }
                } else {
                    setChatMessages(prev => [...prev, { 
                        text: "I received a response but couldn't understand it. Please try again.", 
                        sender: 'chatbot' 
                    }]);
                }
            } catch (error) {
                console.error("Error in chatbot communication:", error);
                
                setChatMessages(prev => [...prev, { 
                    text: `Sorry, there was an error: ${error.message}. Please try again.`, 
                    sender: 'chatbot' 
                }]);
            } finally {
                if (chatLoading) {
                    chatLoading.classList.add('d-none');
                }
                
                updateChatDisplay();
            }
        }, [items, currentItemId]);
    
        // Process suggested items from AI
        const processSuggestedItems = React.useCallback((suggestedItemsArray, currentItem) => {
            if (!Array.isArray(suggestedItemsArray) || !currentItem) {
                console.warn("Invalid suggested items or missing current item");
                return;
            }
    
            const suggestions = suggestedItemsArray.map(item => ({
                id: Utils.generateItemId(),
                title: item.name || 'Unnamed Item',
                content: item.content || '',
                tags: item.tags || '',
                isSuggestion: true
            }));
            
            setSuggestedItems(suggestions);
            
            // Update the suggested items display
            const suggestedItemsContainer = document.getElementById('suggested-items-list');
            const currentItemSpan = document.getElementById('suggested-items-current');
            
            if (currentItemSpan) {
                currentItemSpan.textContent = currentItem.title;
            }
            
            if (suggestedItemsContainer) {
                suggestedItemsContainer.innerHTML = '';
                
                if (suggestions.length === 0) {
                    suggestedItemsContainer.innerHTML = '<div class="alert alert-info">No suggested items available yet.</div>';
                    return;
                }
                
                suggestions.forEach(item => {
                    const itemElement = document.createElement('div');
                    itemElement.className = 'card mb-2';
                    itemElement.draggable = true;
                    itemElement.dataset.id = item.id;
                    
                    itemElement.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', JSON.stringify(item));
                    });
                    
                    itemElement.innerHTML = `
                        <div class="card-body">
                            <h6 class="card-title">${item.title}</h6>
                            <p class="card-text small">${item.content.substring(0, 100)}${item.content.length > 100 ? '...' : ''}</p>
                            <div class="d-flex justify-content-between align-items-center">
                                ${item.tags ? `<div class="item-tags">${item.tags.split(',').map(tag => 
                                    `<span class="badge bg-secondary me-1">${tag.trim()}</span>`).join('')}
                                </div>` : ''}
                                <button class="btn btn-sm btn-primary add-suggestion-btn">
                                    <i class="bi bi-plus-circle me-1"></i> Add
                                </button>
                            </div>
                        </div>
                    `;
                    
                    itemElement.querySelector('.add-suggestion-btn').addEventListener('click', () => {
                        if (currentItemId) {
                            addItem({
                                id: item.id,
                                title: item.title,
                                content: item.content,
                                tags: item.tags,
                                items: []
                            }, currentItemId);
                        } else {
                            addItem({
                                id: item.id,
                                title: item.title,
                                content: item.content,
                                tags: item.tags,
                                items: []
                            });
                        }
                    });
                    
                    suggestedItemsContainer.appendChild(itemElement);
                });
            }
        }, [addItem, currentItemId]);
    
        // Update chat display
        const updateChatDisplay = React.useCallback(() => {
            const chatMessagesContainer = document.getElementById('chat-messages');
            if (chatMessagesContainer) {
                chatMessagesContainer.innerHTML = '';
                
                chatMessages.forEach((msg) => {
                    const messageElement = document.createElement('div');
                    messageElement.className = `${msg.sender === 'user' ? 'alert alert-secondary' : 'alert alert-primary'} mb-2`;
                    messageElement.innerHTML = Utils.renderMarkdown(msg.text);
                    chatMessagesContainer.appendChild(messageElement);
                });
                
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        }, [chatMessages]);
        
        // Export to various formats
        const exportDocument = React.useCallback((format = 'json') => {
            // Create a deep copy of the data to modify for export
            const dataForExport = {
                title: documentTitle,
                items: JSON.parse(JSON.stringify(items))
            };
            
            // Remove IDs if format is json
            if (format === 'json') {
                const removeIdsRecursive = (items) => {
                    if (!items || !Array.isArray(items)) return;
                    
                    items.forEach(item => {
                        // Delete the ID property
                        delete item.id;
                        
                        // Process children recursively
                        if (item.items && Array.isArray(item.items)) {
                            removeIdsRecursive(item.items);
                        }
                    });
                };
                
                removeIdsRecursive(dataForExport.items);
            }
            
            let blob, url, filename, content;
            const timestamp = new Date().toISOString()
                .replace(/T/, '-')
                .replace(/\..+/, '')
                .replace(/:/g, '-')
                .substring(0, 19);
            
            if (format === 'json') {
                content = JSON.stringify(dataForExport, null, 2);
                blob = new Blob([content], { type: "application/json" });
                filename = `${originalFilename || documentTitle.replace(/\s+/g, '_')}_${timestamp}.json`;
                
                url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = filename;
                
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                Utils.showAlert(`Document exported as ${format.toUpperCase()} successfully.`, "success");
            }
        }, [documentTitle, items, originalFilename]);
        
        // Context value for provider
        const contextValue = {
            // State
            items,
            filteredItems,
            documentTitle,
            activeTags,
            currentItemId,
            expandedItems,
            navExpandedItems,
            chatMessages,
            suggestedItems,
            isInfoPanelOpen,
            markdownContent,
            originalFilename,
            
            // State setters
            setItems,
            setFilteredItems,
            setDocumentTitle,
            setCurrentItemId,
            setOriginalFilename,
            setIsInfoPanelOpen,
            
            // Action methods
            addItem,
            updateItem,
            removeItem,
            clearDocument,
            toggleItemExpansion,
            toggleNavExpansion,
            toggleTagFilter,
            importDocument,
            exportDocument,
            sendChatMessage,
            setSuggestedItems,
            fetchMarkdownContent,
            updateDocumentNavigation,
            updateTagFilters,
            scrollToItem,
            reorderItems,
            openMatrixEditor,
            checkRelationReferences
        };
        
        return (
            <DataContext.Provider value={contextValue}>
                {children}
            </DataContext.Provider>
        )
    }
    
    // Matrix Visualization component - improved with memoization
    const MatrixVisualization = React.memo(({ item, items }) => {
        const [activeTab, setActiveTab] = React.useState('heatmap');
        const context = React.useContext(DataContext);
        
        // Refs for the visualization containers
        const heatmapRef = React.useRef(null);
        const sankeyRef = React.useRef(null);
        
        // Effect to create visualizations when component mounts or item changes
        React.useEffect(() => {
            if (activeTab === 'heatmap' && heatmapRef.current) {
                Utils.createHeatmap(heatmapRef.current, item, items);
            } else if (activeTab === 'sankey' && sankeyRef.current) {
                Utils.createSankeyDiagram(sankeyRef.current, item, items);
            }
        }, [item, items, activeTab]);
        
        // Event handlers
        const handleTabChange = tab => {
            setActiveTab(tab);
        };
        
        const handleEditMatrix = () => {
            context.openMatrixEditor(item);
        };
        
        return (
            <div className="matrix-visualization">
                <div className="matrix-visualization-title">Matrix Visualizations</div>
                
                <ul className="nav nav-tabs mb-3">
                    <li className="nav-item">
                        <button 
                            className={`nav-link ${activeTab === 'heatmap' ? 'active' : ''}`}
                            onClick={() => handleTabChange('heatmap')}
                        >
                            <i className="bi bi-grid-3x3 me-1"></i> Heatmap
                        </button>
                    </li>
                    <li className="nav-item">
                        <button 
                            className={`nav-link ${activeTab === 'sankey' ? 'active' : ''}`}
                            onClick={() => handleTabChange('sankey')}
                        >
                            <i className="bi bi-diagram-3 me-1"></i> Sankey Diagram
                        </button>
                    </li>
                </ul>
                <div className="matrix-action-buttons">
                    <button 
                        className="btn btn-primary"
                        onClick={handleEditMatrix}
                    >
                        <i className="bi bi-pencil me-1"></i> Edit Matrix
                    </button>
                </div>
                <div className="visualization-container">
                    <div ref={heatmapRef} style={{ display: activeTab === 'heatmap' ? 'block' : 'none' }}></div>
                    <div ref={sankeyRef} style={{ display: activeTab === 'sankey' ? 'block' : 'none' }}></div>
                </div>
            </div>
        );
    });
    
    // Empty State component for when no items are present
    const EmptyState = React.memo(({ isFiltered, onAddItem }) => {
        return (
            <div className="text-center py-5">
                <p className="lead">
                    {isFiltered 
                        ? 'No items found with the selected tags.' 
                        : 'No items yet. Create your first item to get started.'}
                </p>
                {!isFiltered && (
                    <button 
                        className="btn btn-primary"
                        onClick={onAddItem}
                    >
                        <i className="bi bi-plus-circle me-2"></i> Add First Item
                    </button>
                )}
            </div>
        );
    });
    
    // Item component - renders a single item with all its properties
    const Item = React.memo(({ item, depth = 0 }) => {
        const context = React.useContext(DataContext);
        if (!context) return <div>Loading...</div>;
        
        const {
            currentItemId,
            expandedItems,
            toggleItemExpansion,
            setCurrentItemId,
            setIsInfoPanelOpen,
            fetchMarkdownContent,
            reorderItems,
            addItem
        } = context;
        
        const isExpanded = expandedItems[item.id];
        const hasChildren = React.useMemo(() => Boolean(item.items && item.items.length > 0), [item.items]);
        const isSelected = currentItemId === item.id;
        const isMatrixItem = React.useMemo(() => Boolean(item.tags && item.tags.includes('type::matrix')), [item.tags]);
        
        const itemRef = React.useRef(null);
        const listType = React.useMemo(() => Utils.getTypeFromTags(item.tags) || '', [item.tags]);
        const listIcon = React.useMemo(() => Utils.getListTypeIcon(listType), [listType]);
        const listClass = listType ? `list-${listType}` : '';
        
        // Setup sortable for drag-and-drop
        React.useEffect(() => {
            if (itemRef.current && hasChildren && isExpanded) {
                const sortable = new Sortable(itemRef.current, {
                    group: 'items',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    handle: '.item-drag-handle',
                    onEnd: function(evt) {
                        if (!item.items || evt.oldIndex === undefined || evt.newIndex === undefined) {
                            return;
                        }
                        
                        if (evt.oldIndex < 0 || evt.oldIndex >= item.items.length ||
                            evt.newIndex < 0 || evt.newIndex >= item.items.length) {
                            return;
                        }
    
                        const sourceItem = item.items[evt.oldIndex];
                        if (!sourceItem) return;
    
                        const targetItem = item;
                        const originalItems = [...item.items];
                        
                        Utils.showDragConfirmation(
                            sourceItem, 
                            targetItem,
                            () => {
                                reorderItems(sourceItem.id, item.id, evt.newIndex);
                                Utils.showAlert(`Item "${sourceItem.title}" moved successfully.`, "success");
                            },
                            () => {
                                evt.from.classList.add('restoring');
                                setTimeout(() => {
                                    evt.from.innerHTML = '';
                                    originalItems.forEach(child => {
                                        const placeholder = document.createElement('div');
                                        placeholder.className = 'item-placeholder';
                                        placeholder.dataset.id = child.id;
                                        placeholder.innerHTML = '<div class="p-2">Restoring...</div>';
                                        evt.from.appendChild(placeholder);
                                    });
                                    
                                    setTimeout(() => {
                                        context.updateDocumentNavigation();
                                        context.setItems(prevItems => [...prevItems]); 
                                        evt.from.classList.remove('restoring');
                                    }, 50);
                                }, 50);
                            }
                        );
                    }
                });
                
                return () => sortable.destroy();
            }
        }, [hasChildren, isExpanded, item, context, reorderItems]);
        
        // Memoized handlers
        const handleToggleExpand = React.useCallback(() => {
            toggleItemExpansion(item.id);
        }, [toggleItemExpansion, item.id]);
        
        const handleEditItem = React.useCallback(() => {
            // Save scroll position before opening modal
            Utils.saveScrollPosition();
            
            const modalElement = document.getElementById('item-editor-modal');
            const modal = new bootstrap.Modal(modalElement);
            const titleInput = document.getElementById('item-title');
            const tagsInput = document.getElementById('item-tags');
            const contentInput = document.getElementById('item-content');
            const idInput = document.getElementById('item-id');
            const originalTitleInput = document.getElementById('original-title');
            const parentIdInput = document.getElementById('parent-id');
            const relationsList = document.getElementById('relations-list');
            
            // Fill the form with current values
            titleInput.value = item.title || '';
            originalTitleInput.value = item.title || '';
            tagsInput.value = item.tags || '';
            contentInput.value = item.content || '';
            idInput.value = item.id;
            parentIdInput.value = '';
            
            // Initialize SimpleMDE
            if (window.simpleMDE) {
                window.simpleMDE.value(item.content || '');
                setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
            } else {
                window.simpleMDE = new SimpleMDE({ 
                    element: contentInput,
                    spellChecker: false,
                    status: false
                });
            }
            
            // Initialize Tagify
            if (!window.tagify) {
                // Get all tags from all items to use as whitelist
                const allTags = Utils.extractAllTags(context.items);
                
                window.tagify = new Tagify(tagsInput, {
                    dropdown: {
                        enabled: 1,
                        maxItems: 5,
                        position: "text",
                        closeOnSelect: false,
                        highlightFirst: true,
                        searchKeys: ["value"]
                    },
                    whitelist: allTags,
                    enforceWhitelist: false,
                    pattern: /^(?!.*>>)/,
                    maxTags: 50
                });
                
                new DragSort(window.tagify.DOM.scope, {
                    selector: '.' + window.tagify.settings.classNames.tag,
                    callbacks: {
                        dragEnd: function() {
                            window.tagify.updateValueByDOMTags();
                        }
                    }
                });
            } else {
                window.tagify.removeAllTags();
                
                // Filter out relation tags
                const normalTags = item.tags ? item.tags.split(',')
                    .map(tag => tag.trim())
                    .filter(tag => !tag.includes('>>'))
                    .join(', ') : '';
                
                window.tagify.addTags(normalTags);
                
                // Ensure DragSort is initialized after tags are added
                new DragSort(window.tagify.DOM.scope, {
                    selector: '.' + window.tagify.settings.classNames.tag,
                    callbacks: {
                        dragEnd: function() {
                            window.tagify.updateValueByDOMTags();
                        }
                    }
                });
            }
            
            // Show relations in the relation list
            if (relationsList) {
                const relations = Utils.getRelationsFromTags(item.tags);
                relationsList.innerHTML = Utils.renderRelationTags(relations);
                
                // Clear relation inputs
                const relationType = document.getElementById('relation-type');
                const relationTarget = document.getElementById('relation-target');
                if (relationType) relationType.value = '';
                if (relationTarget) relationTarget.value = '';
                
                // Setup click handler for removing relations
                relationsList.addEventListener('click', function(e) {
                    if (e.target.tagName === 'BUTTON' || e.target.parentElement.tagName === 'BUTTON') {
                        const button = e.target.tagName === 'BUTTON' ? e.target : e.target.parentElement;
                        const relationStr = button.dataset.relation;
                        
                        if (relationStr) {
                            // Update item's tags by removing this relation
                            const newTags = Utils.removeRelationFromTags(item.tags, relationStr.split('>>')[1]);
                            tagsInput.value = newTags;
                            
                            // Re-render relations list
                            const updatedRelations = Utils.getRelationsFromTags(newTags);
                            relationsList.innerHTML = Utils.renderRelationTags(updatedRelations);
                        }
                    }
                });
                
                // Setup add relation button
                document.getElementById('add-relation-btn').onclick = function() {
                    const relationType = document.getElementById('relation-type').value;
                    const targetTitle = document.getElementById('relation-target').value;
                    
                    if (!relationType || !targetTitle) {
                        Utils.showAlert("Please enter both relation type and target item", "warning");
                        return;
                    }
                    
                    // Add relation to tags
                    const updatedTags = Utils.addRelationToTags(tagsInput.value, relationType, targetTitle);
                    tagsInput.value = updatedTags;
                    
                    // Update relations list
                    const relations = Utils.getRelationsFromTags(updatedTags);
                    relationsList.innerHTML = Utils.renderRelationTags(relations);
                    
                    // Clear inputs for next entry
                    document.getElementById('relation-type').value = '';
                    document.getElementById('relation-target').value = '';
                };
            }
            
            document.getElementById('item-editor-title').textContent = 'Edit Item';
            
            // Add event listener for modal hidden to restore scroll position
            modalElement.addEventListener('hidden.bs.modal', function onHidden() {
                Utils.restoreScrollPosition();
                modalElement.removeEventListener('hidden.bs.modal', onHidden);
            });
            
            modal.show();
        }, [context.items, item.content, item.id, item.tags, item.title]);
        
        const handleOpenChat = React.useCallback(() => {
            setCurrentItemId(item.id);
            
            const contextSpan = document.getElementById('current-item-title');
            if (contextSpan) contextSpan.textContent = item.title;
            
            const suggestedItemsCurrent = document.getElementById('suggested-items-current');
            if (suggestedItemsCurrent) suggestedItemsCurrent.textContent = item.title;
            
            chatbotPanel.show();
        }, [setCurrentItemId, item.id, item.title]);
        
        const handleOpenInfo = React.useCallback(async () => {
            setCurrentItemId(item.id);
            await fetchMarkdownContent(item.title);
            setIsInfoPanelOpen(true);
            
            const panelTitle = document.getElementById('info-panel-title');
            if (panelTitle) panelTitle.textContent = `About ${item.title}`;
            
            infoPanel.show();
            
            Utils.updateRelatedItems(context.items, item);
        }, [context.items, fetchMarkdownContent, item, setCurrentItemId, setIsInfoPanelOpen]);
        
        const handleAddChild = React.useCallback(() => {
            // Save scroll position
            Utils.saveScrollPosition();
            
            const modalElement = document.getElementById('item-editor-modal');
            const modal = new bootstrap.Modal(modalElement);
            const titleInput = document.getElementById('item-title');
            const tagsInput = document.getElementById('item-tags');
            const contentInput = document.getElementById('item-content');
            const idInput = document.getElementById('item-id');
            const originalTitleInput = document.getElementById('original-title');
            const parentIdInput = document.getElementById('parent-id');
            const relationsList = document.getElementById('relations-list');
            
            titleInput.value = '';
            originalTitleInput.value = '';
            tagsInput.value = '';
            contentInput.value = '';
            idInput.value = '';
            parentIdInput.value = item.id;
            
            if (window.simpleMDE) {
                window.simpleMDE.value('');
                setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
            } else {
                window.simpleMDE = new SimpleMDE({ 
                    element: contentInput,
                    spellChecker: false,
                    status: false
                });
            }
            
            if (!window.tagify) {
                // Get all tags from all items to use as whitelist
                const allTags = Utils.extractAllTags(context.items);
                
                window.tagify = new Tagify(tagsInput, {
                    dropdown: {
                        enabled: 1,
                        maxItems: 5,
                        position: "text",
                        closeOnSelect: false,
                        highlightFirst: true,
                        searchKeys: ["value"]
                    },
                    whitelist: allTags,
                    enforceWhitelist: false,
                    maxTags: 50
                });
                
                new DragSort(window.tagify.DOM.scope, {
                    selector: '.' + window.tagify.settings.classNames.tag,
                    callbacks: {
                        dragEnd: function() {
                            window.tagify.updateValueByDOMTags();
                        }
                    }
                });
            } else {
                window.tagify.removeAllTags();
                
                // Ensure DragSort is initialized after tags are cleared
                new DragSort(window.tagify.DOM.scope, {
                    selector: '.' + window.tagify.settings.classNames.tag,
                    callbacks: {
                        dragEnd: function() {
                            window.tagify.updateValueByDOMTags();
                        }
                    }
                });
            }
            
            // Reset relations list
            if (relationsList) {
                relationsList.innerHTML = '<div class="alert alert-info">No relations defined</div>';
            }
            
            document.getElementById('item-editor-title').textContent = 'Add New Item';
            
            // Add event listener for modal hidden to restore scroll position
            modalElement.addEventListener('hidden.bs.modal', function onHidden() {
                Utils.restoreScrollPosition();
                modalElement.removeEventListener('hidden.bs.modal', onHidden);
            });
            
            modal.show();
        }, [context.items, item.id]);
        
        // Memoized tag rendering
        const renderedTags = React.useMemo(() => {
            if (!item.tags) return null;
            
            return item.tags.split(',').map((tag, index) => {
                const trimmedTag = tag.trim();
                if (!trimmedTag) return null;
                
                // Skip relation tags and type tags
                if (trimmedTag.includes('>>') || trimmedTag.startsWith('type::')) return null;
                
                return (
                    <span key={`${item.id}-tag-${index}`} className="item-tag">
                        {trimmedTag}
                    </span>
                );
            }).filter(tag => tag !== null);
        }, [item.id, item.tags]);
        
        // Memoized relation rendering
        const renderedRelations = React.useMemo(() => {
            if (!item.tags) return null;
            
            const relations = Utils.getRelationsFromTags(item.tags);
            if (relations.length === 0) return null;
            
            // Check if relations should be collapsed
            const showRelations = expandedItems[`relations-${item.id}`] === true;
            
            return (
                <div className="relation-section">
                    <div className="relation-title d-flex align-items-center">
                        <button 
                            className="btn btn-sm btn-link p-0 me-2"
                            onClick={() => toggleItemExpansion(`relations-${item.id}`)}
                        >
                            <i className={`bi ${showRelations ? 'bi-chevron-down' : 'bi-chevron-right'}`}></i>
                        </button>
                        Relations:
                    </div>
                    
                    {showRelations && (
                        <div className="relation-tags mt-2">
                            {relations.map((rel, index) => {
                                // Get standard relation info
                                const relInfo = RELATION_TYPES[rel.relation] || { 
                                    icon: 'bi-link', 
                                    label: rel.relation,
                                    level: '' 
                                };
                                
                                // Check for numeric value in relation name
                                const colorClass = Utils.getRelationColorClass(rel.relation);
                                
                                // Use either standard level class or new color class
                                let levelClass;
                                if (colorClass) {
                                    levelClass = colorClass;
                                } else {
                                    levelClass = relInfo.level ? `relation-${relInfo.level}` : '';
                                }
                                
                                return (
                                    <span key={`${item.id}-rel-${index}`} className={`relation-tag ${levelClass}`}>
                                        <i className={`bi ${relInfo.icon}`}></i>
                                        {relInfo.label}:&nbsp;
                                        <span className="relation-target">{rel.target}</span>
                                    </span>
                                );
                            })}
                        </div>
                    )}
                </div>
            );
        }, [expandedItems, item.id, item.tags, toggleItemExpansion]);
        
        return (
            <div className={`item-container ${listClass} ${hasChildren ? 'has-children' : ''}`} id={item.id} data-id={item.id}>
                <div className={`item-header ${isSelected ? 'bg-light' : ''}`}>
                    <div className="item-title-area">
                        <button 
                            className="btn btn-sm btn-link p-0 me-2"
                            onClick={handleToggleExpand}
                        >
                            <i className={`bi ${isExpanded ? 'bi-chevron-down' : 'bi-chevron-right'}`}></i>
                        </button>
                        
                        <div className="item-icon">
                            <i className={`bi ${listIcon}`}></i>
                        </div>
                        
                        <h5 className="item-title">{item.title}</h5>
                        
                        <div className="item-tags">
                            {renderedTags}
                        </div>
                        
                        <div className="item-actions">
                            <span className="item-drag-handle action-btn">
                                <i className="bi bi-arrows-move"></i>
                            </span>
                            
                            <button 
                                className="action-btn"
                                onClick={handleEditItem}
                                title="Edit this item"
                            >
                                <i className="bi bi-pencil"></i>
                            </button>
                            
                            <button
                                className="action-btn"
                                onClick={handleOpenChat}
                                title="Ask AI about this item"
                            >
                                <i className="bi bi-chat-dots"></i>
                            </button>
                            
                            <button
                                className="action-btn"
                                onClick={handleOpenInfo}
                                title="Learn more about this concept"
                            >
                                <i className="bi bi-info-circle"></i>
                            </button>
                            
                            <button
                                className="action-btn add-btn"
                                onClick={handleAddChild}
                                title="Add a child item"
                            >
                                <i className="bi bi-plus-circle"></i>
                            </button>
                        </div>
                    </div>
                </div>
                
                {isExpanded && (
                    <div className="item-content">
                        {item.content && (
                            <div 
                                className="markdown-content"
                                dangerouslySetInnerHTML={{ __html: Utils.renderMarkdown(item.content) }}
                            ></div>
                        )}
                        
                        {renderedRelations}
    
                        {isMatrixItem && (
                            <MatrixVisualization item={item} items={context.items} />
                        )}
                    </div>
                )}
                
                {hasChildren && (
                    <div 
                        ref={itemRef}
                        className={`item-children collapse ${isExpanded ? 'show' : ''}`}
                        id={`collapse-${item.id}`}
                    >
                        {item.items.map(child => (
                            <Item 
                                key={child.id} 
                                item={child} 
                                depth={depth + 1}
                            />
                        ))}
                    </div>
                )}
            </div>
        );
    });
    
    // Document component - Shows the document content
    const Document = React.memo(() => {
        const context = React.useContext(DataContext);
        
        if (!context) {
            return <div>Loading document context...</div>;
        }
        
        const { 
            items, 
            filteredItems,
            activeTags
        } = context;
        
        const documentRef = React.useRef(null);
        
        // Memoize displayed items
        const displayItems = React.useMemo(() => {
            return activeTags.includes('all') ? items : filteredItems;
        }, [activeTags, items, filteredItems]);
        
        // Sortable drag handler
        const handleSortEnd = React.useCallback((evt) => {
            if (!displayItems || evt.oldIndex === undefined || evt.newIndex === undefined) {
                return;
            }
            
            if (evt.oldIndex < 0 || evt.oldIndex >= displayItems.length ||
                evt.newIndex < 0 || evt.newIndex >= displayItems.length) {
                return;
            }
            
            const sourceItem = displayItems[evt.oldIndex];
            if (!sourceItem) return;
            
            Utils.showDragConfirmation(
                sourceItem, 
                null,
                () => {
                    const newItems = [...items];
                    let sourceIndex = -1;
                    for (let i = 0; i < newItems.length; i++) {
                        if (newItems[i].id === sourceItem.id) {
                            sourceIndex = i;
                            break;
                        }
                    }
                    
                    if (sourceIndex >= 0) {
                        const [movedItem] = newItems.splice(sourceIndex, 1);
                        newItems.splice(evt.newIndex, 0, movedItem);
                        context.setItems(newItems);
                        Utils.showAlert(`Item "${sourceItem.title}" moved successfully.`, "success");
                    }
                },
                () => {
                    context.setItems([...items]);
                }
            );
        }, [context, displayItems, items]);
        
        // Setup sortable for top-level items
        React.useEffect(() => {
            if (documentRef.current) {
                const sortable = new Sortable(documentRef.current, {
                    group: 'items',
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    chosenClass: 'sortable-chosen',
                    handle: '.item-drag-handle',
                    onEnd: handleSortEnd
                });
                
                return () => {
                    if (sortable && typeof sortable.destroy === 'function') {
                        sortable.destroy();
                    }
                };
            }
        }, [handleSortEnd]);
        
        // Handler to add top-level item
        const handleAddTopLevelItem = React.useCallback(() => {
            if (window.addTopLevelItem) {
                window.addTopLevelItem();
            }
        }, []);
        
        return (
            <div className="document-container">
                <div ref={documentRef} className="items-container">
                    {displayItems.length > 0 ? (
                        displayItems.map(item => (
                            <Item key={item.id} item={item} />
                        ))
                    ) : (
                        <EmptyState 
                            isFiltered={!activeTags.includes('all')} 
                            onAddItem={handleAddTopLevelItem} 
                        />
                    )}
                </div>
            </div>
        );
    });
    
    // App component - Main application component
    const App = React.memo(() => {
        const [isInitialized, setIsInitialized] = React.useState(false);
        
        // Initialize event handlers and data
        React.useEffect(() => {
            // Setup handlers
            const destroyHandlers = setupEventHandlers();
            
            // Try to load data from localStorage
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    if (parsedData && parsedData.items && parsedData.items.length > 0) {
                        initializeApp(parsedData);
                    }
                } catch (error) {
                    console.error("Failed to load data:", error);
                }
            }
            
            return destroyHandlers;
        }, []);
        
        // Setup event handlers for the UI
        const setupEventHandlers = () => {
            // Setup UI event handlers map
            const handlers = {
                // Modal dialog handlers
                handleSaveItem: () => {
                    try {
                        // Save scroll position
                        Utils.saveScrollPosition();
                        
                        const titleInput = document.getElementById('item-title');
                        const contentInput = document.getElementById('item-content');
                        const tagsInput = document.getElementById('item-tags');
                        const idInput = document.getElementById('item-id');
                        const originalTitleInput = document.getElementById('original-title');
                        const parentIdInput = document.getElementById('parent-id');
                        
                        if (!titleInput || !titleInput.value.trim()) {
                            Utils.showAlert("Title is required", "danger");
                            return;
                        }
                        
                        // Get original title for reference change detection
                        const originalTitle = originalTitleInput.value;
                        const newTitle = titleInput.value.trim();
                        
                        // Get tags properly from Tagify if available
                        let normalizedTags = '';
                        if (window.tagify) {
                            try {
                                // Extract regular tags from Tagify
                                normalizedTags = window.tagify.value
                                    .map(t => t.value)
                                    .filter(tag => !tag.includes('>>') && tag.trim())
                                    .join(', ');
                            } catch (e) {
                                console.warn("Error extracting tags from Tagify:", e);
                                normalizedTags = tagsInput ? tagsInput.value : '';
                            }
                        } else if (tagsInput) {
                            normalizedTags = tagsInput.value;
                        }
                        
                        // Get relation tags from the relations list
                        const relationsList = document.getElementById('relations-list');
                        const relationTags = [];
                        
                        if (relationsList) {
                            const relationElements = relationsList.querySelectorAll('.relation-tag');
                            relationElements.forEach(el => {
                                if (el.dataset.relation) {
                                    relationTags.push(el.dataset.relation);
                                }
                            });
                        }
                        
                        // Combine regular tags and relation tags
                        let tags = normalizedTags;
                        if (relationTags.length > 0) {
                            tags = tags ? `${tags}, ${relationTags.join(', ')}` : relationTags.join(', ');
                        }
                        
                        // Check if matrix item
                        const isMatrixItem = idInput && idInput.value && normalizedTags.includes('type::matrix');
                        if (isMatrixItem) {
                            // Find existing item to preserve tags
                            const existingItem = Utils.findItemById(window.app.items, idInput.value);
                            if (existingItem && existingItem.tags) {
                                // Extract matrix tags
                                const matrixTags = existingItem.tags.split(',')
                                    .map(tag => tag.trim())
                                    .filter(tag => 
                                        tag.startsWith('source-item::') || 
                                        tag.startsWith('target-item::') ||
                                        tag.startsWith('values::'))
                                    .join(', ');
                                
                                // Add matrix tags if they exist
                                if (matrixTags) {
                                    tags = tags ? `${tags}, ${matrixTags}` : matrixTags;
                                }
                            }
                        }
                        
                        // Get content from SimpleMDE
                        let content = '';
                        if (window.simpleMDE) {
                            try {
                                content = window.simpleMDE.value();
                            } catch (e) {
                                console.warn("SimpleMDE error:", e);
                                content = contentInput ? contentInput.value || '' : '';
                            }
                        } else {
                            content = contentInput ? contentInput.value || '' : '';
                        }
                        
                        // Create item data
                        const itemData = {
                            title: newTitle,
                            tags: tags,
                            content: content,
                            items: []
                        };
                        
                        // Hide the modal
                        const modalInstance = bootstrap.Modal.getInstance(document.getElementById('item-editor-modal'));
                        if (modalInstance) {
                            modalInstance.hide();
                        }
                        
                        if (idInput && idInput.value) {
                            // Editing existing item
                            itemData.id = idInput.value;
                            
                            // Check if title changed and needs references updated
                            if (originalTitle && originalTitle !== newTitle && window.app?.checkRelationReferences) {
                                window.app.checkRelationReferences(originalTitle, newTitle, itemData, (updated, count) => {
                                    if (updated) {
                                        Utils.showAlert(`Updated ${count} reference${count !== 1 ? 's' : ''} to the renamed item`, "success");
                                    }
                                    window.app.updateItem(itemData);
                                });
                            } else {
                                window.app.updateItem(itemData);
                            }
                            
                            // Open matrix editor if matrix item
                            if (isMatrixItem) {
                                setTimeout(() => {
                                    window.app.openMatrixEditor(itemData);
                                }, 300);
                            }
                        } else {
                            // Creating new item
                            itemData.id = Utils.generateItemId();
                            const parentId = parentIdInput.value || null;
                            
                            if (window.app) {
                                window.app.addItem(itemData, parentId);
                            }
                            
                            // Open matrix editor if matrix item
                            if (tags.includes('type::matrix')) {
                                setTimeout(() => {
                                    const newItem = Utils.findItemById(window.app.items, itemData.id);
                                    if (newItem) {
                                        window.app.openMatrixEditor(newItem);
                                    }
                                }, 300);
                            }
                        }
                        
                        // Restore scroll position
                        Utils.restoreScrollPosition();
                    } catch (error) {
                        console.error("Error saving item:", error);
                        Utils.showAlert("Error saving item: " + error.message, "danger");
                        
                        // Restore scroll position on error
                        Utils.restoreScrollPosition();
                    }
                },
                
                // Button click handlers
                toggleSidebar: (collapse) => {
                    Utils.toggleSidebar(collapse);
                },
                
                handleFileImport: (file) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (!data || !data.items) {
                                throw new Error("Invalid document format");
                            }
                            
                            initializeApp(data, file.name);
                            
                            setTimeout(() => {
                                document.dispatchEvent(new Event('app-imported-data'));
                            }, 500);
                        } catch (error) {
                            console.error("Error importing file:", error);
                            Utils.showAlert("Error importing file: " + error.message, "danger");
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            // Setup button handlers
            const buttonHandlers = [
                { id: 'collapse-sidebar-btn', event: 'click', handler: () => handlers.toggleSidebar(true) },
                { id: 'expand-sidebar-btn', event: 'click', handler: () => handlers.toggleSidebar(false) },
                { id: 'save-item-btn', event: 'click', handler: handlers.handleSaveItem },
                { id: 'export-json-btn', event: 'click', handler: () => window.app?.exportDocument('json') },
                { id: 'create-new-btn', event: 'click', handler: () => initializeApp({ title: "New Document", items: [] }) },
                { id: 'clear-btn', event: 'click', handler: () => new bootstrap.Modal(document.getElementById('clear-confirm-modal')).show() },
                { id: 'confirm-clear-btn', event: 'click', handler: () => { 
                    if (window.app) window.app.clearDocument(); 
                    bootstrap.Modal.getInstance(document.getElementById('clear-confirm-modal')).hide();
                }},
                { id: 'import-btn', event: 'click', handler: () => document.getElementById('file-input').click() },
                { id: 'import-json-btn', event: 'click', handler: () => document.getElementById('file-input').click() },
                { id: 'chat-open-btn', event: 'click', handler: () => chatbotPanel.show() },
                { id: 'delete-item-btn', event: 'click', handler: () => {
                    const id = document.getElementById('item-id').value;
                    if (id) {
                        document.getElementById('confirm-delete-btn').dataset.itemId = id;
                        bootstrap.Modal.getInstance(document.getElementById('item-editor-modal')).hide();
                        new bootstrap.Modal(document.getElementById('delete-confirm-modal')).show();
                    }
                }},
                { id: 'confirm-delete-btn', event: 'click', handler: () => {
                    const id = document.getElementById('confirm-delete-btn').dataset.itemId;
                    if (id && window.app) {
                        window.app.removeItem(id);
                        bootstrap.Modal.getInstance(document.getElementById('delete-confirm-modal')).hide();
                    }
                }},
                { id: 'matrix-view-btn', event: 'click', handler: () => window.app?.openMatrixEditor() },
                { id: 'add-top-item-btn', event: 'click', handler: () => window.addTopLevelItem && window.addTopLevelItem() }
            ];
            
            // Attach all handlers
            buttonHandlers.forEach(({ id, event, handler }) => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener(event, handler);
                }
            });
            
            // File input handler
            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    if (file.name.endsWith('.json')) {
                        handlers.handleFileImport(file);
                    } else {
                        Utils.showAlert("Please upload a valid JSON file", "danger");
                    }
                }
            });
            
            // File dropzone
            const fileDropzone = document.getElementById('file-dropzone');
            fileDropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileDropzone.classList.add('border-primary');
            });
            
            fileDropzone.addEventListener('dragleave', () => {
                fileDropzone.classList.remove('border-primary');
            });
            
            fileDropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                fileDropzone.classList.remove('border-primary');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.name.endsWith('.json')) {
                        handlers.handleFileImport(file);
                    } else {
                        Utils.showAlert("Please upload a valid JSON file", "danger");
                    }
                }
            });
            
            fileDropzone.addEventListener('click', () => {
                fileInput.click();
            });
            
            // Chat message handling
            const chatInput = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-btn');
            
            const sendChatMessage = () => {
                const message = chatInput.value.trim();
                if (message && window.app) {
                    window.app.sendChatMessage(message);
                    chatInput.value = '';
                }
            };
            
            chatSendBtn.addEventListener('click', sendChatMessage);
            
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            // Return cleanup function
            return () => {
                buttonHandlers.forEach(({ id, event, handler }) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.removeEventListener(event, handler);
                    }
                });
            };
        };
        
        // Initialize the app with data
        const initializeApp = (data, filename = "") => {
            if (!data || !data.items) {
                console.error("Invalid data for initialization");
                Utils.showAlert("Invalid document format", "danger");
                return false;
            }
            
            if (window.app) {
                const success = window.app.importDocument(data, filename);
                
                if (success) {
                    document.getElementById('welcome-screen').classList.add('d-none');
                    document.getElementById('document-content').classList.remove('d-none');
                    setIsInitialized(true);
                    
                    setTimeout(() => {
                        window.app.updateDocumentNavigation();
                        window.app.updateTagFilters();
                    }, 200);
                    
                    return true;
                }
                
                return false;
            } else {
                // Store data for later use
                window.initialData = data;
                window.initialFilename = filename;
                document.getElementById('welcome-screen').classList.add('d-none');
                document.getElementById('document-content').classList.remove('d-none');
                setIsInitialized(true);
                
                return true;
            }
        };
        
        // Setup global app functions
        React.useEffect(() => {
            if (isInitialized && window.app) {
                // Define function to add top level item
                window.addTopLevelItem = () => {
                    // Save scroll position
                    Utils.saveScrollPosition();
                    
                    const modalElement = document.getElementById('item-editor-modal');
                    const modal = new bootstrap.Modal(modalElement);
                    const titleInput = document.getElementById('item-title');
                    const tagsInput = document.getElementById('item-tags');
                    const contentInput = document.getElementById('item-content');
                    const idInput = document.getElementById('item-id');
                    const originalTitleInput = document.getElementById('original-title');
                    const parentIdInput = document.getElementById('parent-id');
                    const relationsList = document.getElementById('relations-list');
                    
                    // Clear form
                    titleInput.value = '';
                    originalTitleInput.value = '';
                    tagsInput.value = '';
                    contentInput.value = '';
                    idInput.value = '';
                    parentIdInput.value = '';
                    
                    // Initialize or reset editor
                    if (window.simpleMDE) {
                        window.simpleMDE.value('');
                        setTimeout(() => window.simpleMDE.codemirror.refresh(), 10);
                    } else {
                        window.simpleMDE = new SimpleMDE({ 
                            element: contentInput,
                            spellChecker: false,
                            status: false
                        });
                    }
                    
                    // Initialize or reset tagify
                    if (!window.tagify) {
                        // Get all tags as whitelist
                        const allTags = Utils.extractAllTags(window.app.items);
                        
                        window.tagify = new Tagify(tagsInput, {
                            dropdown: {
                                enabled: 1,
                                maxItems: 5,
                                position: "text",
                                closeOnSelect: false,
                                highlightFirst: true,
                                searchKeys: ["value"]
                            },
                            whitelist: allTags,
                            enforceWhitelist: false,
                            maxTags: 50
                        });
                    } else {
                        window.tagify.removeAllTags();
                    }
                    
                    // Reset relations list
                    if (relationsList) {
                        relationsList.innerHTML = '<div class="alert alert-info">No relations defined</div>';
                    }
                    
                    document.getElementById('item-editor-title').textContent = 'Add New Item';
                    
                    // Restore scroll position when modal closes
                    modalElement.addEventListener('hidden.bs.modal', function onHidden() {
                        Utils.restoreScrollPosition();
                        modalElement.removeEventListener('hidden.bs.modal', onHidden);
                    });
                    
                    modal.show();
                };
                
                // Load initial data if available
                if (window.initialData) {
                    window.app.importDocument(window.initialData, window.initialFilename || "");
                    window.initialData = null;
                    window.initialFilename = null;
                }
            }
        }, [isInitialized]);
        
        if (!isInitialized) {
            return null;
        }
        
        return <Document />;
    });
    
    // Application with context wrapper
    const AppWithContext = () => {
        return (
            <DataProvider>
                <DataContext.Consumer>
                    {(context) => {
                        window.app = context;
                        return <App />;
                    }}
                </DataContext.Consumer>
            </DataProvider>
        )
    }
    
    // Render the application
    root.render(<AppWithContext />);
    </script>

</body>
</html>